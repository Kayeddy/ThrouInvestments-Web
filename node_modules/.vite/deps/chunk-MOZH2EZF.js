import {
  require_callBound,
  require_dist2 as require_dist,
  require_eth_query,
  require_events,
  require_get_intrinsic,
  require_lib,
  require_safe_event_emitter,
  require_shams
} from "./chunk-M25RO4RP.js";
import {
  require_inherits_browser
} from "./chunk-PKEN3KVR.js";
import {
  __commonJS
} from "./chunk-2PXFZ4CE.js";

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name = getter.call(value);
            if (name === typedArray) {
              foundName = name;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/eth-block-tracker/node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/eth-block-tracker/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return new P((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i = 1; i < arguments.length; i++) {
                results2[i - 1] = arguments[i];
              }
              if (err) {
                results2.unshift(err);
                reject(results2);
              } else {
                resolve(results2);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i = 0; i < arguments.length; i++) {
                results2[i] = arguments[i];
              }
              resolve(results2);
            } else {
              resolve(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? processFn(x, opts) : x;
      }
      return ret;
    };
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports, module) {
    var util = require_util();
    var EventEmitter = require_events();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter.call(this);
    }
    util.inherits(SafeEventEmitter, EventEmitter);
    SafeEventEmitter.prototype.emit = function(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          safeApply(listeners[i], this, args);
      }
      return true;
    };
    function safeApply(handler, context, args) {
      try {
        ReflectApply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter2();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      //
      // public
      //
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      // dont allow module consumer to remove our internal event listeners
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      //
      // to be implemented in subclass
      //
      _start() {
      }
      _end() {
      }
      //
      // private
      //
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    var pify = require_pify();
    var BaseBlockTracker = require_base();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      //
      // public
      //
      // trigger block polling
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      //
      // private
      //
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/eth-json-rpc-middleware/node_modules/json-rpc-engine/src/createScaffoldMiddleware.js"(exports, module) {
    module.exports = function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/scaffold.js
var require_scaffold = __commonJS({
  "node_modules/eth-json-rpc-middleware/scaffold.js"(exports, module) {
    module.exports = require_createScaffoldMiddleware();
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn) {
      return "0x" + bn.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i = 0; i < byteCount; i++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log) => this.matchLog(log));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber))
          return false;
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function query(provider, method, params) {
      return new Promise((resolve, reject) => {
        provider.sendAsync({ id: 1, jsonrpc: "2.0", method, params }, (err, res) => {
          if (err)
            return reject(err);
          resolve(res.result);
        });
      });
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    var Mutex = require_lib().Mutex;
    var { createAsyncMiddleware } = require_dist();
    var createJsonRpcMiddleware = require_scaffold();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createJsonRpcMiddleware({
        // install filters
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        // uninstall filters
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        // checking filter changes
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter) => {
            try {
              await filter.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function newBlockFilter() {
        const filter = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function newPendingTransactionFilter() {
        const filter = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results2 = filter.getChangesAndClear();
        return results2;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        if (filter.type === "log") {
          results = filter.getAllResults();
        } else {
          results = [];
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        const result = Boolean(filter);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter;
        filter.id = filterIndex;
        filter.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter = await createFilterFn(...args);
        const result = intToHex(filter.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn) {
      const values = [];
      for (let key in obj) {
        values.push(obj[key]);
      }
      return values;
    }
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var createScaffoldMiddleware = require_scaffold();
    var { createAsyncMiddleware } = require_dist();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results2 = rawBlocks.map(normalizeBlock);
              results2.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter }) {
          filter.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id = req.params[0];
        const subscription = subscriptions[id];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id in subscriptions) {
          subscriptions[id].destroy();
          delete subscriptions[id];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

export {
  require_util,
  require_polling,
  require_eth_json_rpc_filters,
  require_subscriptionManager
};
//# sourceMappingURL=chunk-MOZH2EZF.js.map
