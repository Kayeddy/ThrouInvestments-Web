import {
  ChainId,
  DEFAULT_RPC_URLS,
  ListingType,
  NATIVE_TOKENS,
  SUPPORTED_CHAIN_IDS,
  ThirdwebSDK,
  UserWallet,
  convertToReadableQuantity,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  getProviderForNetwork,
  invariant,
  require_browser_ponyfill,
  require_bs58,
  require_dist as require_dist2,
  require_fast_deep_equal
} from "./chunk-4T4TU347.js";
import {
  BigNumber,
  Web3Provider,
  getDefaultProvider,
  init_lib,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib13,
  init_lib14,
  init_lib15,
  init_lib16,
  init_lib17,
  init_lib18,
  init_lib19,
  init_lib2,
  init_lib20,
  init_lib21,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  lib_exports,
  lib_exports10,
  lib_exports11,
  lib_exports12,
  lib_exports13,
  lib_exports14,
  lib_exports15,
  lib_exports16,
  lib_exports17,
  lib_exports18,
  lib_exports19,
  lib_exports2,
  lib_exports20,
  lib_exports22 as lib_exports21,
  lib_exports23 as lib_exports22,
  lib_exports3,
  lib_exports4,
  lib_exports5,
  lib_exports6,
  lib_exports7,
  lib_exports8,
  lib_exports9,
  utils_exports
} from "./chunk-4GOS6X2N.js";
import {
  require_shim
} from "./chunk-XLAXMYVM.js";
import {
  IJsonRpcConnection,
  IJsonRpcProvider,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  getRpcUrl,
  isHttpUrl,
  isJsonRpcError,
  isJsonRpcResponse,
  parseConnectionError,
  require_cjs,
  require_copy_to_clipboard,
  require_eventemitter3,
  signingMethods
} from "./chunk-AQXEOCVB.js";
import "./chunk-ET6QXWKF.js";
import {
  require_dist
} from "./chunk-33GIUUKA.js";
import {
  require_events
} from "./chunk-F2DI6CH5.js";
import {
  require_buffer
} from "./chunk-BYKJRXDS.js";
import {
  require_bn
} from "./chunk-X56WTLRE.js";
import {
  ThemeProvider,
  emotion_styled_browser_esm_default,
  init_emotion_react_browser_esm,
  init_emotion_styled_browser_esm,
  keyframes
} from "./chunk-24MFR27Q.js";
import "./chunk-LRWWERII.js";
import {
  require_jsx_runtime
} from "./chunk-PRCXZJS3.js";
import {
  require_react_dom
} from "./chunk-IBWEEADP.js";
import {
  require_react
} from "./chunk-TDFPBIOU.js";
import "./chunk-HZQ4F5UU.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-2PXFZ4CE.js";

// node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib10(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib6(), __toCommonJS(lib_exports6));
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib8(), __toCommonJS(lib_exports9)));
    exports.base64 = base64;
    var basex_1 = (init_lib13(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib9(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib15(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib17(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib4(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib14(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib20(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib16(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib3(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib5(), __toCommonJS(lib_exports5)));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib11(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib7(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib12(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib21(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib18(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib19(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib14(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib7(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports, module) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.define(arguments[i2]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t2) {
          return t2.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i2 = 0; i2 < extensions.length; i2++) {
          const ext = extensions[i2];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last2 = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last2.replace(/^.*\./, "").toLowerCase();
      let hasPath = last2.length < path.length;
      let hasDot = ext.length < last2.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports, module) {
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/lite.js
var require_lite = __commonJS({
  "node_modules/mime/lite.js"(exports, module) {
    "use strict";
    var Mime = require_Mime();
    module.exports = new Mime(require_standard());
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len = args.length; i2 < len; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match2;
      var i2;
      var hexAlpha;
      if (match2 = string.match(hex)) {
        hexAlpha = match2[2];
        match2 = match2[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb[i2] = parseInt(match2.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(abbr)) {
        match2 = match2[1];
        hexAlpha = match2[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2] + match2[i2], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(rgba)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2 + 1], 0);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Math.round(parseFloat(match2[i2 + 1]) * 2.55);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(keyword)) {
        if (match2[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match2[1])) {
          return null;
        }
        rgb = colorNames[match2[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = clamp(rgb[i2], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hsl);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match2[2]), 0, 100);
        var l2 = clamp(parseFloat(match2[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a2];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hwb);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var w2 = clamp(parseFloat(match2[2]), 0, 100);
        var b = clamp(parseFloat(match2[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b, a2];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r2 = Math.round(rgba[0] / 255 * 100);
      var g2 = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a2 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a2 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min3, max3) {
      return Math.min(Math.max(min3, num), max3);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min3 = Math.min(r2, g2, b);
      const max3 = Math.max(r2, g2, b);
      const delta = max3 - min3;
      let h2;
      let s2;
      if (max3 === min3) {
        h2 = 0;
      } else if (r2 === max3) {
        h2 = (g2 - b) / delta;
      } else if (g2 === max3) {
        h2 = 2 + (b - r2) / delta;
      } else if (b === max3) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l2 = (min3 + max3) / 2;
      if (max3 === min3) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max3 + min3);
      } else {
        s2 = delta / (2 - max3 - min3);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s2;
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r2, g2, b);
      const diff = v - Math.min(r2, g2, b);
      const diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = 0;
        s2 = 0;
      } else {
        s2 = diff / v;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b);
        if (r2 === v) {
          h2 = bdif - gdif;
        } else if (g2 === v) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g2 = rgb[1];
      let b = rgb[2];
      const h2 = convert.rgb.hsl(rgb)[0];
      const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b));
      b = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b));
      return [h2, w2 * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r2, 1 - g2, 1 - b);
      const c2 = (1 - r2 - k) / (1 - k) || 0;
      const m = (1 - g2 - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r2 * 0.4124 + g2 * 0.3576 + b * 0.1805;
      const y = r2 * 0.2126 + g2 * 0.7152 + b * 0.0722;
      const z = r2 * 0.0193 + g2 * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l2 = 116 * y - 16;
      const a2 = 500 * (x - y);
      const b = 200 * (y - z);
      return [l2, a2, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s2);
      } else {
        t2 = l2 + s2 - l2 * s2;
      }
      const t1 = 2 * l2 - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s2 = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s2;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l2 + s2) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s2 = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f2 = h2 - Math.floor(h2);
      const p2 = 255 * v * (1 - s2);
      const q = 255 * v * (1 - s2 * f2);
      const t2 = 255 * v * (1 - s2 * (1 - f2));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t2, p2];
        case 1:
          return [q, v, p2];
        case 2:
          return [p2, v, t2];
        case 3:
          return [p2, q, v];
        case 4:
          return [t2, p2, v];
        case 5:
          return [v, p2, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s2 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l2;
      l2 = (2 - s2) * v;
      const lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f2;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v = 1 - bl;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      const n2 = wh + f2 * (v - wh);
      let r2;
      let g2;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v;
          g2 = n2;
          b = wh;
          break;
        case 1:
          r2 = n2;
          g2 = v;
          b = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v;
          b = n2;
          break;
        case 3:
          r2 = wh;
          g2 = n2;
          b = v;
          break;
        case 4:
          r2 = n2;
          g2 = wh;
          b = v;
          break;
        case 5:
          r2 = v;
          g2 = wh;
          b = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k) + k);
      const g2 = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r2;
      let g2;
      let b;
      r2 = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g2 = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l2 = 116 * y - 16;
      const a2 = 500 * (x - y);
      const b = 200 * (y - z);
      return [l2, a2, b];
    };
    convert.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l2 + 16) / 116;
      x = a2 / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a2);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c2 = Math.sqrt(a2 * a2 + b * b);
      return [l2, c2, h2];
    };
    convert.lch.lab = function(lch) {
      const l2 = lch[0];
      const c2 = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a2 = c2 * Math.cos(hr);
      const b = c2 * Math.sin(hr);
      return [l2, a2, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g2, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g2 = args[1];
      const b = args[2];
      if (r2 === g2 && g2 === b) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color2 & 1) * mult * 255;
      const g2 = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r2, g2, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r2, g2, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g2 = integer >> 8 & 255;
      const b = integer & 255;
      return [r2, g2, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max3 = Math.max(Math.max(r2, g2), b);
      const min3 = Math.min(Math.min(r2, g2), b);
      const chroma = max3 - min3;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min3 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max3 === r2) {
        hue = (g2 - b) / chroma % 6;
      } else if (max3 === g2) {
        hue = 2 + (b - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
      let f2 = 0;
      if (c2 < 1) {
        f2 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f2 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s2 = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c2 = s2 * v;
      let f2 = 0;
      if (c2 < 1) {
        f2 = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f2 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c2 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v = hi % 1;
      const w2 = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c2) * g2;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v = c2 + g2 * (1 - c2);
      let f2 = 0;
      if (v > 0) {
        f2 = c2 / v;
      }
      return [hcg[0], f2 * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l2 = g2 * (1 - c2) + 0.5 * c2;
      let s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v = c2 + g2 * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c2 = v - w2;
      let g2 = 0;
      if (c2 < 1) {
        g2 = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i2 = 0; i2 < len; i2++) {
        const toModel = models[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i2;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color2 = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color2.push(object[labels[i2]]);
        }
        this.color = zeroArray(color2);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          const limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self = this.model in colorString.to ? this : this.rgb();
        self = self.round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to[self.model](args);
      },
      percentString(places) {
        const self = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i2, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i2] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i2 = 0; i2 < 3; i2++) {
          rgb.color[i2] = 255 - rgb.color[i2];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p2 = weight === void 0 ? 0.5 : weight;
        const w2 = 2 * p2 - 1;
        const a2 = color1.alpha() - color2.alpha();
        const w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
        const w22 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w22 * color2.red(),
          w1 * color1.green() + w22 * color2.green(),
          w1 * color1.blue() + w22 * color2.blue(),
          color1.alpha() * p2 + color2.alpha() * (1 - p2)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color(this);
        }
        if (args.length > 0) {
          return new Color(args, model);
        }
        return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...args) {
        let color2 = args[0];
        if (typeof color2 === "number") {
          color2 = zeroArray(args, channels);
        }
        return new Color(color2, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max3) {
      return function(v) {
        return Math.max(0, Math.min(max3, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array, length) {
      for (let i2 = 0; i2 < length; i2++) {
        if (typeof array[i2] !== "number") {
          array[i2] = 0;
        }
      }
      return array;
    }
    module.exports = Color;
  }
});

// node_modules/@react-icons/all-files/lib/cjs/iconsManifest.js
var require_iconsManifest = __commonJS({
  "node_modules/@react-icons/all-files/lib/cjs/iconsManifest.js"(exports, module) {
    module.exports.IconsManifest = [
      {
        "id": "fa",
        "name": "Font Awesome",
        "projectUrl": "https://fontawesome.com/",
        "license": "CC BY 4.0 License",
        "licenseUrl": "https://creativecommons.org/licenses/by/4.0/"
      },
      {
        "id": "io",
        "name": "Ionicons 4",
        "projectUrl": "https://ionicons.com/",
        "license": "MIT",
        "licenseUrl": "https://github.com/ionic-team/ionicons/blob/master/LICENSE"
      },
      {
        "id": "io5",
        "name": "Ionicons 5",
        "projectUrl": "https://ionicons.com/",
        "license": "MIT",
        "licenseUrl": "https://github.com/ionic-team/ionicons/blob/master/LICENSE"
      },
      {
        "id": "md",
        "name": "Material Design icons",
        "projectUrl": "http://google.github.io/material-design-icons/",
        "license": "Apache License Version 2.0",
        "licenseUrl": "https://github.com/google/material-design-icons/blob/master/LICENSE"
      },
      {
        "id": "ti",
        "name": "Typicons",
        "projectUrl": "http://s-ings.com/typicons/",
        "license": "CC BY-SA 3.0",
        "licenseUrl": "https://creativecommons.org/licenses/by-sa/3.0/"
      },
      {
        "id": "go",
        "name": "Github Octicons icons",
        "projectUrl": "https://octicons.github.com/",
        "license": "MIT",
        "licenseUrl": "https://github.com/primer/octicons/blob/master/LICENSE"
      },
      {
        "id": "fi",
        "name": "Feather",
        "projectUrl": "https://feathericons.com/",
        "license": "MIT",
        "licenseUrl": "https://github.com/feathericons/feather/blob/master/LICENSE"
      },
      {
        "id": "gi",
        "name": "Game Icons",
        "projectUrl": "https://game-icons.net/",
        "license": "CC BY 3.0",
        "licenseUrl": "https://creativecommons.org/licenses/by/3.0/"
      },
      {
        "id": "wi",
        "name": "Weather Icons",
        "projectUrl": "https://erikflowers.github.io/weather-icons/",
        "license": "SIL OFL 1.1",
        "licenseUrl": "http://scripts.sil.org/OFL"
      },
      {
        "id": "di",
        "name": "Devicons",
        "projectUrl": "https://vorillaz.github.io/devicons/",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "ai",
        "name": "Ant Design Icons",
        "projectUrl": "https://github.com/ant-design/ant-design-icons",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "bs",
        "name": "Bootstrap Icons",
        "projectUrl": "https://github.com/twbs/icons",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "ri",
        "name": "Remix Icon",
        "projectUrl": "https://github.com/Remix-Design/RemixIcon",
        "license": "Apache License Version 2.0",
        "licenseUrl": "http://www.apache.org/licenses/"
      },
      {
        "id": "fc",
        "name": "Flat Color Icons",
        "projectUrl": "https://github.com/icons8/flat-color-icons",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "gr",
        "name": "Grommet-Icons",
        "projectUrl": "https://github.com/grommet/grommet-icons",
        "license": "Apache License Version 2.0",
        "licenseUrl": "http://www.apache.org/licenses/"
      },
      {
        "id": "hi",
        "name": "Heroicons",
        "projectUrl": "https://github.com/refactoringui/heroicons",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "si",
        "name": "Simple Icons",
        "projectUrl": "https://simpleicons.org/",
        "license": "CC0 1.0 Universal",
        "licenseUrl": "https://creativecommons.org/publicdomain/zero/1.0/"
      },
      {
        "id": "im",
        "name": "IcoMoon Free",
        "projectUrl": "https://github.com/Keyamoon/IcoMoon-Free",
        "license": "CC BY 4.0 License"
      },
      {
        "id": "bi",
        "name": "BoxIcons",
        "projectUrl": "https://github.com/atisawd/boxicons",
        "license": "CC BY 4.0 License"
      },
      {
        "id": "cg",
        "name": "css.gg",
        "projectUrl": "https://github.com/astrit/css.gg",
        "license": "MIT",
        "licenseUrl": "https://opensource.org/licenses/MIT"
      },
      {
        "id": "vsc",
        "name": "VS Code Icons",
        "projectUrl": "https://github.com/microsoft/vscode-codicons",
        "license": "CC BY 4.0",
        "licenseUrl": "https://creativecommons.org/licenses/by/4.0/"
      }
    ];
  }
});

// node_modules/@react-icons/all-files/lib/cjs/iconContext.js
var require_iconContext = __commonJS({
  "node_modules/@react-icons/all-files/lib/cjs/iconContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IconContext = exports.DefaultContext = void 0;
    var React13 = require_react();
    exports.DefaultContext = {
      color: void 0,
      size: void 0,
      className: void 0,
      style: void 0,
      attr: void 0
    };
    exports.IconContext = React13.createContext && React13.createContext(exports.DefaultContext);
  }
});

// node_modules/@react-icons/all-files/lib/cjs/iconBase.js
var require_iconBase = __commonJS({
  "node_modules/@react-icons/all-files/lib/cjs/iconBase.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
            t2[p2[i2]] = s2[p2[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IconBase = exports.GenIcon = void 0;
    var React13 = require_react();
    var iconContext_1 = require_iconContext();
    function Tree2Element(tree) {
      return tree && tree.map(function(node, i2) {
        return React13.createElement(node.tag, __assign({ key: i2 }, node.attr), Tree2Element(node.child));
      });
    }
    function GenIcon(data) {
      return function(props) {
        return React13.createElement(IconBase, __assign({ attr: __assign({}, data.attr) }, props), Tree2Element(data.child));
      };
    }
    exports.GenIcon = GenIcon;
    function IconBase(props) {
      var elem = function(conf) {
        var attr = props.attr, size2 = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
        var computedSize = size2 || conf.size || "1em";
        var className;
        if (conf.className)
          className = conf.className;
        if (props.className)
          className = (className ? className + " " : "") + props.className;
        return React13.createElement(
          "svg",
          __assign({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, conf.attr, attr, svgProps, { className, style: __assign(__assign({ color: props.color || conf.color }, conf.style), props.style), height: computedSize, width: computedSize, xmlns: "http://www.w3.org/2000/svg" }),
          title && React13.createElement("title", null, title),
          props.children
        );
      };
      return iconContext_1.IconContext !== void 0 ? React13.createElement(iconContext_1.IconContext.Consumer, null, function(conf) {
        return elem(conf);
      }) : elem(iconContext_1.DefaultContext);
    }
    exports.IconBase = IconBase;
  }
});

// node_modules/@react-icons/all-files/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@react-icons/all-files/lib/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !exports2.hasOwnProperty(p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_iconsManifest(), exports);
    __exportStar(require_iconBase(), exports);
    __exportStar(require_iconContext(), exports);
  }
});

// node_modules/@react-icons/all-files/fi/FiCheck.js
var require_FiCheck = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiCheck.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiCheck = function FiCheck2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "20 6 9 17 4 12" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiChevronDown.js
var require_FiChevronDown = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiChevronDown.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiChevronDown = function FiChevronDown2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "6 9 12 15 18 9" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiCopy.js
var require_FiCopy = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiCopy.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiCopy = function FiCopy2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "x": "9", "y": "9", "width": "13", "height": "13", "rx": "2", "ry": "2" } }, { "tag": "path", "attr": { "d": "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiLock.js
var require_FiLock = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiLock.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiLock = function FiLock2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "x": "3", "y": "11", "width": "18", "height": "11", "rx": "2", "ry": "2" } }, { "tag": "path", "attr": { "d": "M7 11V7a5 5 0 0 1 10 0v4" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiShuffle.js
var require_FiShuffle = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiShuffle.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiShuffle = function FiShuffle2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "16 3 21 3 21 8" } }, { "tag": "line", "attr": { "x1": "4", "y1": "20", "x2": "21", "y2": "3" } }, { "tag": "polyline", "attr": { "points": "21 16 21 21 16 21" } }, { "tag": "line", "attr": { "x1": "15", "y1": "15", "x2": "21", "y2": "21" } }, { "tag": "line", "attr": { "x1": "4", "y1": "4", "x2": "9", "y2": "9" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiWifi.js
var require_FiWifi = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiWifi.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiWifi = function FiWifi2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M5 12.55a11 11 0 0 1 14.08 0" } }, { "tag": "path", "attr": { "d": "M1.42 9a16 16 0 0 1 21.16 0" } }, { "tag": "path", "attr": { "d": "M8.53 16.11a6 6 0 0 1 6.95 0" } }, { "tag": "line", "attr": { "x1": "12", "y1": "20", "x2": "12.01", "y2": "20" } }] })(props);
    };
  }
});

// node_modules/@react-icons/all-files/fi/FiXCircle.js
var require_FiXCircle = __commonJS({
  "node_modules/@react-icons/all-files/fi/FiXCircle.js"(exports, module) {
    var GenIcon = require_cjs2().GenIcon;
    module.exports.FiXCircle = function FiXCircle2(props) {
      return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" } }, { "tag": "line", "attr": { "x1": "15", "y1": "9", "x2": "9", "y2": "15" } }, { "tag": "line", "attr": { "x1": "9", "y1": "9", "x2": "15", "y2": "15" } }] })(props);
    };
  }
});

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.esm.js
var import_bn = __toESM(require_bn());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_merkletreejs = __toESM(require_dist2());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_bs58 = __toESM(require_bs58());
globalThis.global = globalThis;

// node_modules/@thirdweb-dev/react/dist/index-aed60ee9.esm.js
var import_react6 = __toESM(require_react());

// node_modules/wagmi/dist/wagmi.esm.js
var React = __toESM(require_react());

// node_modules/wagmi-core/dist/base-2a0d02bb.esm.js
var import_eventemitter32 = __toESM(require_eventemitter3());
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
var chain = {
  mainnet: {
    id: 1,
    name: "Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://mainnet.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://etherscan.io"
    }]
  },
  ropsten: {
    id: 3,
    name: "Ropsten",
    nativeCurrency: {
      name: "Ropsten Ether",
      symbol: "ropETH",
      decimals: 18
    },
    rpcUrls: ["https://ropsten.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://ropsten.etherscan.io"
    }],
    testnet: true
  },
  rinkeby: {
    id: 4,
    name: "Rinkeby",
    nativeCurrency: {
      name: "Rinkeby Ether",
      symbol: "rETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://rinkeby.etherscan.io"
    }],
    testnet: true
  },
  gnosis: {
    id: 100,
    name: "Gnosis Chain",
    nativeCurrency: {
      name: "xDai",
      symbol: "xDAI",
      decimals: 18
    },
    rpcUrls: ["https://rpc.gnosischain.com"],
    blockExplorers: [{
      name: "Blockscout",
      url: "https://blockscout.com"
    }]
  },
  goerli: {
    id: 5,
    name: "Goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "gETH",
      decimals: 18
    },
    rpcUrls: ["https://goerli.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }],
    testnet: true
  },
  kovan: {
    id: 42,
    name: "Kovan",
    nativeCurrency: {
      name: "Kovan Ether",
      symbol: "kETH",
      decimals: 18
    },
    rpcUrls: ["https://kovan.infura.io/v3"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan.etherscan.io"
    }],
    testnet: true
  },
  optimism: {
    id: 10,
    name: "Optimism",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://optimistic.etherscan.io"
    }]
  },
  optimismKovan: {
    id: 69,
    name: "Optimism Kovan",
    nativeCurrency: {
      name: "Kovan Ether",
      symbol: "KOR",
      decimals: 18
    },
    rpcUrls: ["https://kovan.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan-optimistic.etherscan.io"
    }],
    testnet: true
  },
  polygonMainnet: {
    id: 137,
    name: "Polygon Mainnet",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://polygonscan.com"
    }]
  },
  polygonTestnetMumbai: {
    id: 80001,
    name: "Mumbai",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://mumbai.polygonscan.com"
    }],
    testnet: true
  },
  arbitrumOne: {
    id: 42161,
    name: "Arbitrum One",
    nativeCurrency: {
      name: "Ether",
      symbol: "AETH",
      decimals: 18
    },
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://arbiscan.io"
    }, {
      name: "Arbitrum Explorer",
      url: "https://explorer.arbitrum.io"
    }]
  },
  arbitrumRinkeby: {
    id: 421611,
    name: "Arbitrum Rinkeby",
    nativeCurrency: {
      name: "Arbitrum Rinkeby Ether",
      symbol: "ARETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbitrum Explorer",
      url: "https://rinkeby-explorer.arbitrum.io"
    }],
    testnet: true
  },
  avalanche: {
    id: 43114,
    name: "Avalanche Mainnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://snowtrace.io"
    }],
    testnet: false
  },
  avalancheFuji: {
    id: 43113,
    name: "Avalanche Fuji Testnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io"
    }],
    testnet: true
  },
  localhost: {
    id: 1337,
    name: "Localhost",
    rpcUrls: ["https://127.0.0.1:8545"]
  },
  hardhat: {
    id: 31337,
    name: "Hardhat",
    rpcUrls: ["http://127.0.0.1:8545"]
  }
};
var allChains = Object.values(chain);
var defaultChains = [chain.mainnet, chain.ropsten, chain.rinkeby, chain.goerli, chain.kovan];
var defaultL2Chains = [chain.gnosis, chain.optimism, chain.optimismKovan, chain.polygonMainnet, chain.polygonTestnetMumbai, chain.arbitrumOne, chain.arbitrumRinkeby];
var developmentChains = [chain.localhost, chain.hardhat];
var normalizeChainId = (chainId) => {
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  return chainId;
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "AddChainError");
    _defineProperty(this, "message", "Error adding chain");
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ChainNotConfigured");
    _defineProperty(this, "message", "Chain not configured");
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorAlreadyConnectedError");
    _defineProperty(this, "message", "Connector already connected");
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "ConnectorNotFoundError");
    _defineProperty(this, "message", "Connector not found");
  }
};
var SwitchChainError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "SwitchChainError");
    _defineProperty(this, "message", "Error switching chain");
  }
};
var UserRejectedRequestError = class extends Error {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", "UserRejectedRequestError");
    _defineProperty(this, "message", "User rejected request");
  }
};
var Connector = class extends import_eventemitter32.default {
  /** Unique connector id */
  /** Connector name */
  /** Chains connector supports */
  /** Options to use with connector */
  /** Whether connector is usable */
  constructor(_ref) {
    let {
      chains = defaultChains,
      options
    } = _ref;
    super();
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ready", void 0);
    this.chains = chains;
    this.options = options;
  }
  isChainUnsupported(chainId) {
    return !this.chains.some((x) => x.id === chainId);
  }
};

// node_modules/wagmi-core/dist/wagmi-core.esm.js
var import_utils = __toESM(require_utils());
var import_eventemitter33 = __toESM(require_eventemitter3());
var getInjectedName = (ethereum) => {
  if (!ethereum)
    return "Injected";
  if (ethereum.isBraveWallet)
    return "Brave Wallet";
  if (ethereum.isMetaMask)
    return "MetaMask";
  if (ethereum.isCoinbaseWallet)
    return "Coinbase Wallet";
  if (ethereum.isFrame)
    return "Frame";
  if (ethereum.isTally)
    return "Tally";
  return "Injected";
};
var shimKey = "wagmi.shimDisconnect";
var _provider = /* @__PURE__ */ new WeakMap();
var InjectedConnector = class extends Connector {
  constructor(config) {
    super({
      ...config,
      options: config === null || config === void 0 ? void 0 : config.options
    });
    _defineProperty(this, "id", "injected");
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "ready", typeof window != "undefined" && !!window.ethereum);
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      var _this$options;
      this.emit("disconnect");
      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect)
        typeof localStorage !== "undefined" && localStorage.removeItem(shimKey);
    });
    let name = "Injected";
    if (typeof window !== "undefined")
      name = getInjectedName(window.ethereum);
    this.name = name;
  }
  async connect() {
    try {
      var _this$options3;
      const provider = this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        var _this$options2;
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        if (!((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimChainChangedDisconnect))
          provider.on("disconnect", this.onDisconnect);
      }
      const account = await this.getAccount();
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect)
        typeof localStorage !== "undefined" && localStorage.setItem(shimKey, "true");
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider
      };
    } catch (error) {
      if (error.code === 4001)
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    var _this$options4;
    const provider = this.getProvider();
    if (!(provider !== null && provider !== void 0 && provider.removeListener))
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect)
      typeof localStorage !== "undefined" && localStorage.removeItem(shimKey);
  }
  async getAccount() {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    return (0, import_utils.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return await provider.request({
      method: "eth_chainId"
    }).then(normalizeChainId);
  }
  getProvider() {
    if (typeof window !== "undefined" && !!window.ethereum)
      _classPrivateFieldSet(this, _provider, window.ethereum);
    return _classPrivateFieldGet(this, _provider);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      var _this$options5;
      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && typeof localStorage !== "undefined" && !localStorage.getItem(shimKey))
        return false;
      const provider = this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      const account = accounts[0];
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id = (0, import_utils.hexValue)(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      const chains = [...this.chains, ...allChains];
      return chains.find((x) => x.id === chainId);
    } catch (error) {
      if (error.code === 4902) {
        try {
          var _chain$blockExplorers;
          const chain3 = this.chains.find((x) => x.id === chainId);
          if (!chain3)
            throw new ChainNotConfiguredError();
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: id,
              chainName: chain3.name,
              nativeCurrency: chain3.nativeCurrency,
              rpcUrls: chain3.rpcUrls,
              blockExplorerUrls: (_chain$blockExplorers = chain3.blockExplorers) === null || _chain$blockExplorers === void 0 ? void 0 : _chain$blockExplorers.map((x) => x.url)
            }]
          });
          return chain3;
        } catch (addError) {
          throw new AddChainError();
        }
      } else if (error.code === 4001)
        throw new UserRejectedRequestError();
      else
        throw new SwitchChainError();
    }
  }
  async watchAsset(_ref) {
    let {
      address,
      decimals = 18,
      image,
      symbol
    } = _ref;
    const provider = this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    await provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
};

// node_modules/wagmi/dist/wagmi.esm.js
var useProvider = () => {
  const {
    state
  } = useContext2();
  return state.provider;
};
var useCacheBuster = () => {
  const context = useContext2();
  return context.state.cacheBuster;
};
var useCancel = () => {
  const cancelCallback = React.useRef(null);
  React.useEffect(() => {
    return () => {
      var _cancelCallback$curre;
      return (_cancelCallback$curre = cancelCallback.current) === null || _cancelCallback$curre === void 0 ? void 0 : _cancelCallback$curre.call(cancelCallback);
    };
  }, []);
  const cancel = React.useCallback((callback) => {
    var _cancelCallback$curre2;
    (_cancelCallback$curre2 = cancelCallback.current) === null || _cancelCallback$curre2 === void 0 ? void 0 : _cancelCallback$curre2.call(cancelCallback);
    if (callback)
      cancelCallback.current = callback;
  }, []);
  return cancel;
};
var useLocalStorage = function(key) {
  let defaultState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  const [value, setValue] = React.useState(() => {
    if (typeof localStorage === "undefined")
      return defaultState;
    const value2 = localStorage.getItem(key);
    try {
      return value2 ? JSON.parse(value2) : defaultState;
    } catch (error) {
      console.warn(error);
      return defaultState;
    }
  });
  const setLocalStorage = React.useCallback((newValue) => {
    if (newValue === value)
      return;
    setValue(newValue);
    if (newValue === null)
      localStorage.removeItem(key);
    else
      localStorage.setItem(key, JSON.stringify(newValue));
    if (newValue === null) {
      localStorage.removeItem(key);
    } else {
      try {
        localStorage.setItem(key, JSON.stringify(newValue));
      } catch (error) {
        console.error(error);
      }
    }
  }, [value, setValue, key]);
  return [value, setLocalStorage];
};
var initialState$g = {
  loading: false
};
var useEnsAvatar = function() {
  let {
    addressOrName,
    skip
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const provider = useProvider();
  const [state, setState] = React.useState(initialState$g);
  const cancelQuery = useCancel();
  const getEnsAvatar = React.useCallback(async (config) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const config_ = config !== null && config !== void 0 ? config : {
        addressOrName
      };
      if (!config_.addressOrName)
        throw new Error("addressOrName is required");
      setState((x) => ({
        ...x,
        error: void 0,
        loading: true
      }));
      const avatar = await provider.getAvatar(config_.addressOrName);
      if (!didCancel) {
        setState((x) => ({
          ...x,
          avatar,
          loading: false
        }));
      }
      return avatar;
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x) => ({
          ...x,
          error,
          loading: false
        }));
      }
      return error;
    }
  }, [addressOrName, cancelQuery, provider]);
  React.useEffect(() => {
    if (skip || !addressOrName)
      return;
    getEnsAvatar({
      addressOrName
    });
    return cancelQuery;
  }, [addressOrName, cacheBuster, cancelQuery, skip]);
  return [{
    data: state.avatar,
    loading: state.loading,
    error: state.error
  }, getEnsAvatar];
};
var initialState$f = {
  loading: false
};
var useEnsLookup = function() {
  let {
    address,
    skip
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const provider = useProvider();
  const [state, setState] = React.useState(initialState$f);
  const cancelQuery = useCancel();
  const lookupAddress = React.useCallback(async (config) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const config_ = config !== null && config !== void 0 ? config : {
        address
      };
      if (!config_.address)
        throw new Error("address is required");
      setState((x) => ({
        ...x,
        error: void 0,
        loading: true
      }));
      const ens = await provider.lookupAddress(config_.address);
      if (!didCancel) {
        setState((x) => ({
          ...x,
          ens,
          loading: false
        }));
      }
      return {
        data: ens,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x) => ({
          ...x,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [address, cancelQuery, provider]);
  React.useEffect(() => {
    if (skip || !address)
      return;
    lookupAddress({
      address
    });
    return cancelQuery;
  }, [address, cacheBuster, cancelQuery, skip]);
  return [{
    data: state.ens,
    loading: state.loading,
    error: state.error
  }, lookupAddress];
};
var useAccount = function() {
  var _globalState$data;
  let {
    fetchEns
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    state: globalState,
    setState
  } = useContext2();
  const address = (_globalState$data = globalState.data) === null || _globalState$data === void 0 ? void 0 : _globalState$data.account;
  const [{
    data: ens,
    error: ensError,
    loading: ensLoading
  }] = useEnsLookup({
    address,
    skip: !fetchEns
  });
  const [{
    data: avatar,
    error: avatarError,
    loading: avatarLoading
  }] = useEnsAvatar({
    addressOrName: ens,
    skip: !fetchEns || !ens
  });
  const disconnect = React.useCallback(() => {
    setState((x) => {
      var _x$connector;
      (_x$connector = x.connector) === null || _x$connector === void 0 ? void 0 : _x$connector.disconnect();
      return {
        cacheBuster: x.cacheBuster + 1
      };
    });
  }, [setState]);
  const error = ensError || avatarError;
  const loading = ensLoading || avatarLoading;
  return [{
    data: address ? {
      address,
      connector: globalState.connector,
      ens: ens ? {
        avatar,
        name: ens
      } : void 0
    } : void 0,
    error,
    loading
  }, disconnect];
};
var initialState$9 = {
  loading: false
};
var useConnect = () => {
  var _globalState$data;
  const {
    state: globalState,
    setState: setGlobalState,
    setLastUsedConnector
  } = useContext2();
  const [state, setState] = React.useState(initialState$9);
  const cancelQuery = useCancel();
  const connect2 = React.useCallback(async (connector) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      const activeConnector = globalState === null || globalState === void 0 ? void 0 : globalState.connector;
      if (connector === activeConnector)
        throw new ConnectorAlreadyConnectedError();
      setState((x) => ({
        ...x,
        loading: true,
        connector,
        error: void 0
      }));
      const data = await connector.connect();
      if (!didCancel) {
        setGlobalState((x) => ({
          ...x,
          connector,
          data
        }));
        setLastUsedConnector(connector.name);
        setState((x) => ({
          ...x,
          loading: false
        }));
      }
      return {
        data,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x) => ({
          ...x,
          connector: void 0,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [cancelQuery, globalState.connector, setGlobalState, setLastUsedConnector]);
  React.useEffect(() => {
    setState((x) => ({
      ...x,
      connector: globalState.connector,
      error: void 0
    }));
    return cancelQuery;
  }, [cancelQuery, globalState.connector]);
  return [{
    data: {
      connected: !!((_globalState$data = globalState.data) !== null && _globalState$data !== void 0 && _globalState$data.account),
      connector: state.connector,
      connectors: globalState.connectors
    },
    error: state.error,
    loading: state.loading || globalState.connecting
  }, connect2];
};
var initialState$8 = {
  loading: false
};
var useNetwork = () => {
  var _data$chain, _data$chain2, _connector$chains;
  const {
    state: {
      connector,
      data
    }
  } = useContext2();
  const [state, setState] = React.useState(initialState$8);
  const chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id;
  const unsupported = data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.unsupported;
  const activeChains = (_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : [];
  const activeChain = [...activeChains, ...allChains].find((x) => x.id === chainId);
  const cancelQuery = useCancel();
  const switchNetwork = React.useCallback(async (chainId2) => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    if (!(connector !== null && connector !== void 0 && connector.switchChain))
      return {
        data: void 0,
        error: new SwitchChainError()
      };
    try {
      setState((x) => ({
        ...x,
        error: void 0,
        loading: true
      }));
      const chain3 = await connector.switchChain(chainId2);
      if (!didCancel) {
        setState((x) => ({
          ...x,
          loading: false
        }));
      }
      return {
        data: chain3,
        error: void 0
      };
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x) => ({
          ...x,
          error,
          loading: false
        }));
      }
      return {
        data: void 0,
        error
      };
    }
  }, [cancelQuery, connector]);
  return [{
    data: {
      chain: chainId ? {
        ...activeChain,
        id: chainId,
        unsupported
      } : void 0,
      chains: activeChains
    },
    error: state.error,
    loading: state.loading
  }, connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork : void 0];
};
var initialState$7 = {
  data: void 0,
  error: void 0,
  loading: false
};
var useSigner = function() {
  let {
    skip
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const cacheBuster = useCacheBuster();
  const {
    state: {
      connector
    }
  } = useContext2();
  const [state, setState] = React.useState(initialState$7);
  const cancelQuery = useCancel();
  const getSigner = React.useCallback(async () => {
    let didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });
    try {
      setState((x) => ({
        ...x,
        error: void 0,
        loading: true
      }));
      const signer = await (connector === null || connector === void 0 ? void 0 : connector.getSigner());
      if (!didCancel) {
        setState((x) => ({
          ...x,
          data: signer,
          loading: false
        }));
      }
      return signer;
    } catch (error_) {
      const error = error_;
      if (!didCancel) {
        setState((x) => ({
          ...x,
          data: void 0,
          error,
          loading: false
        }));
      }
    }
  }, [cancelQuery, connector]);
  React.useEffect(() => {
    if (skip)
      return;
    getSigner();
    return cancelQuery;
  }, [cacheBuster, connector, cancelQuery, skip]);
  return [state, getSigner];
};
var Context = React.createContext(null);
var Provider = (_ref) => {
  var _state$data2, _state$data2$chain, _state$data4, _state$data4$chain, _state$data6, _state$data6$chain;
  let {
    autoConnect = false,
    children,
    connectors: connectors_ = [new InjectedConnector()],
    connectorStorageKey = "wagmi.wallet",
    provider: provider_ = getDefaultProvider(),
    webSocketProvider: webSocketProvider_
  } = _ref;
  const [lastUsedConnector, setLastUsedConnector] = useLocalStorage(connectorStorageKey);
  const [state, setState] = React.useState({
    cacheBuster: 1,
    connecting: autoConnect
  });
  const connectors = React.useMemo(() => {
    var _state$data, _state$data$chain;
    if (typeof connectors_ !== "function")
      return connectors_;
    return connectors_({
      chainId: (_state$data = state.data) === null || _state$data === void 0 ? void 0 : (_state$data$chain = _state$data.chain) === null || _state$data$chain === void 0 ? void 0 : _state$data$chain.id
    });
  }, [connectors_, (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : (_state$data2$chain = _state$data2.chain) === null || _state$data2$chain === void 0 ? void 0 : _state$data2$chain.id]);
  const provider = React.useMemo(() => {
    var _state$data3, _state$data3$chain;
    if (typeof provider_ !== "function")
      return provider_;
    return provider_({
      chainId: (_state$data3 = state.data) === null || _state$data3 === void 0 ? void 0 : (_state$data3$chain = _state$data3.chain) === null || _state$data3$chain === void 0 ? void 0 : _state$data3$chain.id,
      connector: state.connector
    });
  }, [provider_, (_state$data4 = state.data) === null || _state$data4 === void 0 ? void 0 : (_state$data4$chain = _state$data4.chain) === null || _state$data4$chain === void 0 ? void 0 : _state$data4$chain.id, state.connector]);
  const webSocketProvider = React.useMemo(() => {
    var _state$data5, _state$data5$chain;
    if (!webSocketProvider_)
      return void 0;
    if (typeof webSocketProvider_ !== "function")
      return webSocketProvider_;
    return webSocketProvider_({
      chainId: (_state$data5 = state.data) === null || _state$data5 === void 0 ? void 0 : (_state$data5$chain = _state$data5.chain) === null || _state$data5$chain === void 0 ? void 0 : _state$data5$chain.id,
      connector: state.connector
    });
  }, [webSocketProvider_, (_state$data6 = state.data) === null || _state$data6 === void 0 ? void 0 : (_state$data6$chain = _state$data6.chain) === null || _state$data6$chain === void 0 ? void 0 : _state$data6$chain.id, state.connector]);
  React.useEffect(() => {
    if (!autoConnect)
      return;
    (async () => {
      setState((x) => ({
        ...x,
        connecting: true
      }));
      const sorted = lastUsedConnector ? [...connectors].sort((x) => x.name === lastUsedConnector ? -1 : 1) : connectors;
      for (const connector of sorted) {
        if (!connector.ready || !connector.isAuthorized)
          continue;
        const isAuthorized = await connector.isAuthorized();
        if (!isAuthorized)
          continue;
        const data = await connector.connect();
        setState((x) => ({
          ...x,
          connector,
          data
        }));
        break;
      }
      setState((x) => ({
        ...x,
        connecting: false
      }));
    })();
  }, []);
  React.useEffect(() => {
    return () => {
      if (!state.connector)
        return;
      state.connector.disconnect();
    };
  }, [state.connector]);
  React.useEffect(() => {
    if (!state.connector)
      return;
    const onChange = (data) => setState((x) => ({
      ...x,
      cacheBuster: x.cacheBuster + 1,
      data: {
        ...x.data,
        ...data
      }
    }));
    const onDisconnect = () => setState({
      cacheBuster: 1
    });
    const onError = (error) => setState((x) => ({
      ...x,
      error
    }));
    state.connector.on("change", onChange);
    state.connector.on("disconnect", onDisconnect);
    state.connector.on("error", onError);
    return () => {
      if (!state.connector)
        return;
      state.connector.off("change", onChange);
      state.connector.off("disconnect", onDisconnect);
      state.connector.off("error", onError);
    };
  }, [state.connector]);
  const value = {
    state: {
      cacheBuster: state.cacheBuster,
      connecting: state.connecting,
      connectors,
      connector: state.connector,
      data: state.data,
      provider,
      webSocketProvider
    },
    setState,
    setLastUsedConnector
  };
  return React.createElement(Context.Provider, {
    value
  }, children);
};
var useContext2 = () => {
  const context = React.useContext(Context);
  if (!context)
    throw Error("Must be used within Provider");
  return context;
};

// node_modules/wagmi-core/connectors/coinbaseWallet/dist/wagmi-core-connectors-coinbaseWallet.esm.js
var import_wallet_sdk = __toESM(require_dist());
var import_utils2 = __toESM(require_utils());
var import_eventemitter34 = __toESM(require_eventemitter3());
var _client = /* @__PURE__ */ new WeakMap();
var _provider2 = /* @__PURE__ */ new WeakMap();
var CoinbaseWalletConnector = class extends Connector {
  constructor(config) {
    var _window$ethereum;
    super(config);
    _defineProperty(this, "id", "coinbasewallet");
    _defineProperty(this, "name", "Coinbase Wallet");
    _defineProperty(this, "ready", typeof window !== "undefined" && !((_window$ethereum = window.ethereum) !== null && _window$ethereum !== void 0 && _window$ethereum.isCoinbaseWallet));
    _classPrivateFieldInitSpec(this, _client, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils2.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect() {
    try {
      const provider = this.getProvider();
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      const accounts = await provider.enable();
      const account = (0, import_utils2.getAddress)(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider: new Web3Provider(provider)
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    if (!_classPrivateFieldGet(this, _provider2))
      return;
    const provider = this.getProvider();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    provider.disconnect();
    provider.close();
    if (typeof localStorage !== "undefined") {
      let n2 = localStorage.length;
      while (n2--) {
        const key = localStorage.key(n2);
        if (!key)
          continue;
        if (!/-walletlink/.test(key))
          continue;
        localStorage.removeItem(key);
      }
    }
  }
  async getAccount() {
    const provider = this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return (0, import_utils2.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  getProvider() {
    if (!_classPrivateFieldGet(this, _provider2)) {
      _classPrivateFieldSet(this, _client, new import_wallet_sdk.CoinbaseWalletSDK(this.options));
      _classPrivateFieldSet(this, _provider2, _classPrivateFieldGet(this, _client).makeWeb3Provider(this.options.jsonRpcUrl));
    }
    return _classPrivateFieldGet(this, _provider2);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const provider = this.getProvider();
    const id = (0, import_utils2.hexValue)(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: id
        }]
      });
      const chains = [...this.chains, ...allChains];
      return chains.find((x) => x.id === chainId);
    } catch (error) {
      if (/user rejected signature request/i.test(error.message))
        throw new UserRejectedRequestError();
      else
        throw new SwitchChainError();
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
var import_eventemitter36 = __toESM(require_eventemitter3());

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_events = __toESM(require_events());
var JsonRpcProvider = class extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new import_events.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e2) {
          reject(e2);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e2) {
        reject(e2);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", () => this.events.emit("disconnect"));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.hasRegisteredEventListeners = true;
  }
};

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
var import_events2 = __toESM(require_events());
var import_cross_fetch2 = __toESM(require_browser_ponyfill());

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
var DEFAULT_HTTP_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};
var DEFAULT_HTTP_METHOD = "POST";
var DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD
};
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
var HttpConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events2.EventEmitter();
    this.isAvailable = false;
    this.registering = false;
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    if (!this.isAvailable) {
      throw new Error("Connection already closed");
    }
    this.onClose();
  }
  async send(payload, context) {
    if (!this.isAvailable) {
      await this.register();
    }
    try {
      const body = safeJsonStringify(payload);
      const res = await (0, import_cross_fetch2.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      const data = await res.json();
      this.onPayload({ data });
    } catch (e2) {
      this.onError(payload.id, e2);
    }
  }
  async register(url = this.url) {
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.isAvailable === "undefined") {
            return reject(new Error("HTTP connection is missing or invalid"));
          }
          resolve();
        });
      });
    }
    this.url = url;
    this.registering = true;
    try {
      const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
      await (0, import_cross_fetch2.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      this.onOpen();
    } catch (e2) {
      const error = this.parseError(e2);
      this.events.emit("register_error", error);
      this.onClose();
      throw error;
    }
  }
  onOpen() {
    this.isAvailable = true;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false;
    this.registering = false;
    this.events.emit("close");
  }
  onPayload(e2) {
    if (typeof e2.data === "undefined")
      return;
    const payload = typeof e2.data === "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", payload);
  }
  onError(id, e2) {
    const error = this.parseError(e2);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id, message);
    this.events.emit("payload", payload);
  }
  parseError(e2, url = this.url) {
    return parseConnectionError(e2, url, "HTTP");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
};

// node_modules/@walletconnect/signer-connection/dist/esm/index.js
var import_eventemitter35 = __toESM(require_eventemitter3());
var import_qrcode_modal = __toESM(require_cjs());
var SignerConnection = class extends IJsonRpcConnection {
  constructor(opts) {
    super();
    this.events = new import_eventemitter35.default();
    this.accounts = [];
    this.chainId = 1;
    this.pending = false;
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModalOptions = void 0;
    this.opts = opts;
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.wc = this.register(opts);
  }
  get connected() {
    return typeof this.wc !== "undefined" && this.wc.connected;
  }
  get connecting() {
    return this.pending;
  }
  get connector() {
    this.wc = this.register(this.opts);
    return this.wc;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(chainId) {
    if (this.connected) {
      this.onOpen();
      return;
    }
    return new Promise((resolve, reject) => {
      this.on("error", (err) => {
        reject(err);
      });
      this.on("open", () => {
        resolve();
      });
      this.create(chainId);
    });
  }
  async close() {
    if (typeof this.wc === "undefined")
      return;
    if (this.wc.connected) {
      this.wc.killSession();
    }
    this.onClose();
  }
  async send(payload) {
    this.wc = this.register(this.opts);
    if (!this.connected)
      await this.open();
    this.sendPayload(payload).then((res) => this.events.emit("payload", res)).catch((e2) => this.events.emit("payload", formatJsonRpcError(payload.id, e2.message)));
  }
  register(opts) {
    if (this.wc)
      return this.wc;
    this.opts = opts || this.opts;
    this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector) ? opts.connector.bridge : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
    this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
    this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
    this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
    const connectorOpts = {
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? import_qrcode_modal.default : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    };
    this.wc = typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new esm_default(connectorOpts);
    if (typeof this.wc === "undefined") {
      throw new Error("Failed to register WalletConnect connector");
    }
    if (this.wc.accounts.length) {
      this.accounts = this.wc.accounts;
    }
    if (this.wc.chainId) {
      this.chainId = this.wc.chainId;
    }
    this.registerConnectorEvents();
    return this.wc;
  }
  onOpen(wc) {
    this.pending = false;
    if (wc) {
      this.wc = wc;
    }
    this.events.emit("open");
  }
  onClose() {
    this.pending = false;
    if (this.wc) {
      this.wc = void 0;
    }
    this.events.emit("close");
  }
  onError(payload, message = "Failed or Rejected Request", code = -32e3, data) {
    const errorPayload = {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      error: { code, message }
    };
    if (typeof data !== "undefined") {
      errorPayload.error.data = data;
    }
    this.events.emit("payload", errorPayload);
    return errorPayload;
  }
  create(chainId) {
    this.wc = this.register(this.opts);
    this.chainId = chainId || this.chainId;
    if (this.connected || this.pending)
      return;
    this.pending = true;
    this.registerConnectorEvents();
    this.wc.createSession({ chainId: this.chainId }).then(() => this.events.emit("created")).catch((e2) => this.events.emit("error", e2));
  }
  registerConnectorEvents() {
    this.wc = this.register(this.opts);
    this.wc.on("connect", (err) => {
      var _a, _b;
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.accounts = ((_a = this.wc) === null || _a === void 0 ? void 0 : _a.accounts) || [];
      this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;
      this.onOpen();
    });
    this.wc.on("disconnect", (err) => {
      if (err) {
        this.events.emit("error", err);
        return;
      }
      this.onClose();
    });
    this.wc.on("modal_closed", () => {
      this.events.emit("error", new Error("User closed modal"));
    });
    this.wc.on("session_update", (error, payload) => {
      const { accounts, chainId } = payload.params[0];
      if (!this.accounts || accounts && this.accounts !== accounts) {
        this.accounts = accounts;
        this.events.emit("accountsChanged", accounts);
      }
      if (!this.chainId || chainId && this.chainId !== chainId) {
        this.chainId = chainId;
        this.events.emit("chainChanged", chainId);
      }
    });
  }
  async sendPayload(payload) {
    this.wc = this.register(this.opts);
    try {
      const response = await this.wc.unsafeSend(payload);
      return this.sanitizeResponse(response);
    } catch (error) {
      return this.onError(payload, error.message);
    }
  }
  sanitizeResponse(response) {
    return typeof response.error !== "undefined" && typeof response.error.code === "undefined" ? formatJsonRpcError(response.id, response.error.message, response.error.data) : response;
  }
};

// node_modules/@walletconnect/ethereum-provider/dist/esm/index.js
var WalletConnectProvider = class {
  constructor(opts) {
    this.events = new import_eventemitter36.default();
    this.rpc = { infuraId: opts === null || opts === void 0 ? void 0 : opts.infuraId, custom: opts === null || opts === void 0 ? void 0 : opts.rpc };
    this.signer = new JsonRpcProvider(new SignerConnection(opts));
    const chainId = this.signer.connection.chainId || (opts === null || opts === void 0 ? void 0 : opts.chainId) || 1;
    this.http = this.setHttpProvider(chainId);
    this.registerEventListeners();
  }
  get connected() {
    return this.signer.connection.connected;
  }
  get connector() {
    return this.signer.connection.connector;
  }
  get accounts() {
    return this.signer.connection.accounts;
  }
  get chainId() {
    return this.signer.connection.chainId;
  }
  get rpcUrl() {
    var _a;
    return ((_a = this.http) === null || _a === void 0 ? void 0 : _a.connection).url || "";
  }
  async request(args) {
    switch (args.method) {
      case "eth_requestAccounts":
        await this.connect();
        return this.signer.connection.accounts;
      case "eth_accounts":
        return this.signer.connection.accounts;
      case "eth_chainId":
        return this.signer.connection.chainId;
      default:
        break;
    }
    if (signingMethods.includes(args.method)) {
      return this.signer.request(args);
    }
    if (typeof this.http === "undefined") {
      throw new Error(`Cannot request JSON-RPC method (${args.method}) without provided rpc url`);
    }
    return this.http.request(args);
  }
  sendAsync(args, callback) {
    this.request(args).then((response) => callback(null, response)).catch((error) => callback(error, void 0));
  }
  async enable() {
    const accounts = await this.request({ method: "eth_requestAccounts" });
    return accounts;
  }
  async connect() {
    if (!this.signer.connection.connected) {
      await this.signer.connect();
    }
  }
  async disconnect() {
    if (this.signer.connection.connected) {
      await this.signer.disconnect();
    }
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  get isWalletConnect() {
    return true;
  }
  registerEventListeners() {
    this.signer.connection.on("accountsChanged", (accounts) => {
      this.events.emit("accountsChanged", accounts);
    });
    this.signer.connection.on("chainChanged", (chainId) => {
      this.http = this.setHttpProvider(chainId);
      this.events.emit("chainChanged", chainId);
    });
    this.signer.on("disconnect", () => {
      this.events.emit("disconnect");
    });
  }
  setHttpProvider(chainId) {
    const rpcUrl = getRpcUrl(chainId, this.rpc);
    if (typeof rpcUrl === "undefined")
      return void 0;
    const http = new JsonRpcProvider(new HttpConnection(rpcUrl));
    return http;
  }
};
var esm_default2 = WalletConnectProvider;

// node_modules/wagmi-core/connectors/walletConnect/dist/wagmi-core-connectors-walletConnect.esm.js
var import_utils4 = __toESM(require_utils());
var import_eventemitter37 = __toESM(require_eventemitter3());
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var switchChainAllowedRegex = /(rainbow)/i;
var _provider3 = /* @__PURE__ */ new WeakMap();
var _switchChain = /* @__PURE__ */ new WeakSet();
var WalletConnectConnector = class extends Connector {
  constructor(config) {
    super(config);
    _classPrivateMethodInitSpec(this, _switchChain);
    _defineProperty(this, "id", "walletConnect");
    _defineProperty(this, "name", "WalletConnect");
    _defineProperty(this, "ready", true);
    _classPrivateFieldInitSpec(this, _provider3, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils4.getAddress)(accounts[0])
        });
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", () => {
      this.emit("disconnect");
    });
  }
  async connect() {
    try {
      var _provider$connector$p, _provider$connector, _provider$connector$p2;
      const provider = this.getProvider(true);
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      const accounts = await provider.enable();
      const account = (0, import_utils4.getAddress)(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      const walletName = (_provider$connector$p = (_provider$connector = provider.connector) === null || _provider$connector === void 0 ? void 0 : (_provider$connector$p2 = _provider$connector.peerMeta) === null || _provider$connector$p2 === void 0 ? void 0 : _provider$connector$p2.name) !== null && _provider$connector$p !== void 0 ? _provider$connector$p : "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = _classPrivateMethodGet(this, _switchChain, _switchChain2);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider: new Web3Provider(provider)
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError();
      throw error;
    }
  }
  async disconnect() {
    const provider = this.getProvider();
    await provider.disconnect();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider = this.getProvider();
    const accounts = provider.accounts;
    return (0, import_utils4.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  getProvider(create) {
    if (!_classPrivateFieldGet(this, _provider3) || create)
      _classPrivateFieldSet(this, _provider3, new esm_default2(this.options));
    return _classPrivateFieldGet(this, _provider3);
  }
  async getSigner() {
    const provider = this.getProvider();
    const account = await this.getAccount();
    return new Web3Provider(provider).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
};
async function _switchChain2(chainId) {
  const provider = this.getProvider();
  const id = (0, import_utils4.hexValue)(chainId);
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{
        chainId: id
      }]
    });
    const chains = [...this.chains, ...allChains];
    return chains.find((x) => x.id === chainId);
  } catch (error) {
    const message = typeof error === "string" ? error : error === null || error === void 0 ? void 0 : error.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError();
    else
      throw new SwitchChainError();
  }
}

// node_modules/@thirdweb-dev/react/dist/index-aed60ee9.esm.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@tanstack/query-core/build/lib/subscribable.mjs
var Subscribable = class {
  constructor() {
    this.listeners = [];
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.push(listener);
    this.onSubscribe();
    return () => {
      this.listeners = this.listeners.filter((x) => x !== listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.length > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/lib/utils.mjs
var isServer = typeof window === "undefined" || "Deno" in window;
function noop() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey
  } = filters;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a2, b) {
  return partialDeepEqual(a2, b);
}
function partialDeepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (a2 && b && typeof a2 === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialDeepEqual(a2[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b) {
  if (a2 === b) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b);
  if (array || isPlainObject(a2) && isPlainObject(b)) {
    const aSize = array ? a2.length : Object.keys(a2).length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array ? i2 : bItems[i2];
      copy2[key] = replaceEqualDeep(a2[key], b[key]);
      if (copy2[key] === a2[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b;
}
function shallowEqualObjects(a2, b) {
  if (a2 && !b || b && !a2) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
  return;
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData;
  } else if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}

// node_modules/@tanstack/query-core/build/lib/focusManager.mjs
var FocusManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
};
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/lib/onlineManager.mjs
var OnlineManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        window.addEventListener("online", listener, false);
        window.addEventListener("offline", listener, false);
        return () => {
          window.removeEventListener("online", listener);
          window.removeEventListener("offline", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
};
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/lib/retryer.mjs
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort == null ? void 0 : config.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess == null ? void 0 : config.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError == null ? void 0 : config.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || !shouldPause()) {
          return continueResolve(value);
        }
      };
      config.onPause == null ? void 0 : config.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue == null ? void 0 : config.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail == null ? void 0 : config.onFail(failureCount, error);
      sleep(delay).then(() => {
        if (shouldPause()) {
          return pause();
        }
        return;
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
    },
    cancelRetry,
    continueRetry
  };
}

// node_modules/@tanstack/query-core/build/lib/logger.mjs
var defaultLogger = console;

// node_modules/@tanstack/query-core/build/lib/notifyManager.mjs
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/lib/removable.mjs
var Removable = class {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout);
      this.gcTimeout = void 0;
    }
  }
};

// node_modules/@tanstack/query-core/build/lib/query.mjs
var Query = class extends Removable {
  constructor(config) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.cache = config.cache;
    this.logger = config.logger || defaultLogger;
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.initialState = config.state || getDefaultState(this.options);
    this.state = this.initialState;
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.indexOf(observer) !== -1) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (!Array.isArray(this.options.queryKey)) {
      if (true) {
        this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
      }
    }
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        if (true) {
          this.logger.error(error);
        }
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on2, _this$cache$config2;
        if (typeof data === "undefined") {
          if (true) {
            this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
          }
          onError(new Error("undefined"));
          return;
        }
        this.setData(data);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        this.dispatch({
          type: "failed",
          failureCount,
          error
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer = (state) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState
            };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = typeof data !== "undefined";
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/lib/queryCache.mjs
var QueryCache = class extends Subscribable {
  constructor(config) {
    super();
    this.config = config || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client, options, state) {
    var _options$queryHash;
    const queryKey = options.queryKey;
    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client.getLogger(),
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x) => x !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/lib/mutation.mjs
var Mutation = class extends Removable {
  constructor(config) {
    super();
    this.options = {
      ...config.defaultOptions,
      ...config.options
    };
    this.mutationId = config.mutationId;
    this.mutationCache = config.mutationCache;
    this.logger = config.logger || defaultLogger;
    this.observers = [];
    this.state = config.state || getDefaultState2();
    this.updateCacheTime(this.options.cacheTime);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    if (this.retryer) {
      this.retryer.continue();
      return this.retryer.promise;
    }
    return this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data = await executeMutation();
      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data
      });
      return data;
    } catch (error) {
      try {
        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;
        await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this));
        if (true) {
          this.logger.error(error);
        }
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "loading":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}

// node_modules/@tanstack/query-core/build/lib/mutationCache.mjs
var MutationCache = class extends Subscribable {
  constructor(config) {
    super();
    this.config = config || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client.getLogger(),
      mutationId: ++this.mutationId,
      options: client.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x) => x !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
  }
};

// node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i2 = 1; i2 < oldPages.length; i2++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}

// node_modules/@tanstack/query-core/build/lib/queryClient.mjs
var QueryClient = class {
  constructor(config = {}) {
    this.queryCache = config.queryCache || new QueryCache();
    this.mutationCache = config.mutationCache || new MutationCache();
    this.logger = config.logger || defaultLogger;
    this.defaultOptions = config.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
    this.mountCount = 0;
    if (config.logger) {
      this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
    }
  }
  mount() {
    this.mountCount++;
    if (this.mountCount !== 1)
      return;
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    this.mountCount--;
    if (this.mountCount !== 0)
      return;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    this.unsubscribeFocus = void 0;
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
    this.unsubscribeOnline = void 0;
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  ensureQueryData(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const cachedData = this.getQueryData(parsedOptions.queryKey);
    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey,
      state
    }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const query = this.queryCache.find(queryKey);
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs(queryKey);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options,
        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop);
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options) {
    this.defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    const result = this.queryDefaults.find((x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options
      });
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x) => partialMatchKey(queryKey, x.queryKey));
    if (true) {
      const matchingDefaults = this.queryDefaults.filter((x) => partialMatchKey(queryKey, x.queryKey));
      if (matchingDefaults.length > 1) {
        this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey, options) {
    const result = this.mutationDefaults.find((x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options
      });
    }
  }
  getMutationDefaults(mutationKey) {
    if (!mutationKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x) => partialMatchKey(mutationKey, x.mutationKey));
    if (true) {
      const matchingDefaults = this.mutationDefaults.filter((x) => partialMatchKey(mutationKey, x.mutationKey));
      if (matchingDefaults.length > 1) {
        this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
      }
    }
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
};

// node_modules/@tanstack/query-core/build/lib/queryObserver.mjs
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.length === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = [];
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (typeof (options == null ? void 0 : options.isDataEqual) !== "undefined") {
      this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option");
    }
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      });
    }
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    return this.createResult(query, options);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = void 0;
    }
  }
  clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data = options.select(state.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          if (true) {
            this.client.getLogger().error(selectError);
          }
          this.selectError = selectError;
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            this.selectError = null;
          } catch (selectError) {
            if (true) {
              this.client.getLogger().error(selectError);
            }
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const isLoading = status === "loading";
    const isError2 = status === "error";
    const result = {
      status,
      fetchStatus,
      isLoading,
      isSuccess: status === "success",
      isError: isError2,
      isInitialLoading: isLoading && isFetching,
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      failureReason: state.fetchFailureReason,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isLoading,
      isLoadingError: isError2 && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: isError2 && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key) => {
        const typedKey = key;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
};
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}

// node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs
var MutationObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.client.defaultMutationOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.currentMutation,
        observer: this
      });
    }
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      var _this$currentMutation;
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState2();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
    });
  }
};

// node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.mjs
var ReactDOM = __toESM(require_react_dom(), 1);
var unstable_batchedUpdates2 = ReactDOM.unstable_batchedUpdates;

// node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.mjs
notifyManager.setBatchNotifyFunction(unstable_batchedUpdates2);

// node_modules/@tanstack/react-query/build/lib/useQueries.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs
var import_shim = __toESM(require_shim(), 1);
var useSyncExternalStore = import_shim.useSyncExternalStore;

// node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs
var React2 = __toESM(require_react(), 1);
var defaultContext = React2.createContext(void 0);
var QueryClientSharingContext = React2.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
var useQueryClient = ({
  context
} = {}) => {
  const queryClient = React2.useContext(getQueryClientContext(context, React2.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
var QueryClientProvider = ({
  client,
  children,
  context,
  contextSharing = false
}) => {
  React2.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  if (contextSharing) {
    client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
  }
  const Context2 = getQueryClientContext(context, contextSharing);
  return React2.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, React2.createElement(Context2.Provider, {
    value: client
  }, children));
};

// node_modules/@tanstack/react-query/build/lib/isRestoring.mjs
var React3 = __toESM(require_react(), 1);
var IsRestoringContext = React3.createContext(false);
var useIsRestoring = () => React3.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs
var React4 = __toESM(require_react(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React4.createContext(createValue());
var useQueryErrorResetBoundary = () => React4.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs
var React5 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/utils.mjs
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React5.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  useErrorBoundary,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
};

// node_modules/@tanstack/react-query/build/lib/suspense.mjs
var ensureStaleTime = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
  data
}) => {
  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
}).catch((error) => {
  errorResetBoundary.clearReset();
  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
});

// node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs
var React7 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer) {
  const queryClient = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = React7.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore(React7.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React7.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    useErrorBoundary: defaultedOptions.useErrorBoundary,
    query: observer.getCurrentQuery()
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/lib/useQuery.mjs
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}

// node_modules/@tanstack/react-query/build/lib/Hydrate.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useIsFetching.mjs
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useIsMutating.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useMutation.mjs
var React11 = __toESM(require_react(), 1);
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = React11.useState(() => new MutationObserver(queryClient, options));
  React11.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore(React11.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = React11.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop2);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop2() {
}

// node_modules/@thirdweb-dev/react/dist/required-param-0716d650.esm.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var QueryClientProviderWithDefault = (_ref) => {
  let {
    queryClient,
    children
  } = _ref;
  const queryClientWithDefault = (0, import_react.useMemo)(() => {
    return queryClient ? queryClient : new QueryClient();
  }, [queryClient]);
  return (0, import_jsx_runtime.jsx)(QueryClientProvider, {
    client: queryClientWithDefault,
    children
  });
};
var NEVER_PERSIST_QUERY_POSTFIX = {
  persist: false
};
function neverPersist(key) {
  return [...key, NEVER_PERSIST_QUERY_POSTFIX];
}
function shouldNeverPersistQuery(key) {
  return key[key.length - 1] === NEVER_PERSIST_QUERY_POSTFIX;
}
function requiredParamInvariant(condition, message) {
  invariant(condition !== null || condition !== void 0, message);
}

// node_modules/@thirdweb-dev/react/dist/useConnect-5f21135e.esm.js
function useConnect2() {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useConnect() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own connection logic.`);
  return useConnect();
}

// node_modules/@thirdweb-dev/react/dist/index-aed60ee9.esm.js
var import_buffer = __toESM(require_buffer());
var import_lite = __toESM(require_lite());

// node_modules/react-cool-dimensions/dist/index.esm.js
var import_react2 = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var useLatest = function(val) {
  var ref2 = (0, import_react2.useRef)(val);
  ref2.current = val;
  return ref2;
};
var observerErr = " react-cool-dimensions: the browser doesn't support Resize Observer, please use polyfill: https://github.com/wellyshen/react-cool-dimensions#resizeobserver-polyfill";
var borderBoxWarn = " react-cool-dimensions: the browser doesn't support border-box size, fallback to content-box size. Please see: https://github.com/wellyshen/react-cool-dimensions#border-box-size-measurement";
var getCurrentBreakpoint = function getCurrentBreakpoint2(bps, w2) {
  var curBp = "";
  var max3 = -1;
  Object.keys(bps).forEach(function(key) {
    var val = bps[key];
    if (w2 >= val && val > max3) {
      curBp = key;
      max3 = val;
    }
  });
  return curBp;
};
var useDimensions = function useDimensions2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, useBorderBoxSize = _ref.useBorderBoxSize, breakpoints = _ref.breakpoints, updateOnBreakpointChange = _ref.updateOnBreakpointChange, shouldUpdate = _ref.shouldUpdate, onResize = _ref.onResize, polyfill = _ref.polyfill;
  var _useState = (0, import_react2.useState)({
    currentBreakpoint: "",
    width: 0,
    height: 0
  }), state = _useState[0], setState = _useState[1];
  var prevSizeRef = (0, import_react2.useRef)({});
  var prevBreakpointRef = (0, import_react2.useRef)();
  var observerRef = (0, import_react2.useRef)();
  var warnedRef = (0, import_react2.useRef)(false);
  var ref2 = (0, import_react2.useRef)();
  var onResizeRef = useLatest(onResize);
  var shouldUpdateRef = useLatest(shouldUpdate);
  var unobserve = (0, import_react2.useCallback)(function() {
    if (observerRef.current)
      observerRef.current.disconnect();
  }, []);
  var observe = (0, import_react2.useCallback)(function(element) {
    if (element && element !== ref2.current) {
      unobserve();
      ref2.current = element;
    }
    if (observerRef.current && ref2.current)
      observerRef.current.observe(ref2.current);
  }, [unobserve]);
  (0, import_react2.useEffect)(function() {
    if ((!("ResizeObserver" in window) || !("ResizeObserverEntry" in window)) && !polyfill) {
      console.error(observerErr);
      return function() {
        return null;
      };
    }
    var raf2 = null;
    observerRef.current = new (polyfill || ResizeObserver)(function(_ref2) {
      var entry = _ref2[0];
      raf2 = requestAnimationFrame(function() {
        var contentBoxSize = entry.contentBoxSize, borderBoxSize = entry.borderBoxSize, contentRect = entry.contentRect;
        var boxSize = contentBoxSize;
        if (useBorderBoxSize) {
          if (borderBoxSize) {
            boxSize = borderBoxSize;
          } else if (!warnedRef.current) {
            console.warn(borderBoxWarn);
            warnedRef.current = true;
          }
        }
        boxSize = Array.isArray(boxSize) ? boxSize[0] : boxSize;
        var width = boxSize ? boxSize.inlineSize : contentRect.width;
        var height = boxSize ? boxSize.blockSize : contentRect.height;
        if (width === prevSizeRef.current.width && height === prevSizeRef.current.height)
          return;
        prevSizeRef.current = {
          width,
          height
        };
        var e2 = {
          currentBreakpoint: "",
          width,
          height,
          entry,
          observe,
          unobserve
        };
        if (breakpoints) {
          e2.currentBreakpoint = getCurrentBreakpoint(breakpoints, width);
          if (e2.currentBreakpoint !== prevBreakpointRef.current) {
            if (onResizeRef.current)
              onResizeRef.current(e2);
            prevBreakpointRef.current = e2.currentBreakpoint;
          }
        } else if (onResizeRef.current) {
          onResizeRef.current(e2);
        }
        var next = {
          currentBreakpoint: e2.currentBreakpoint,
          width,
          height,
          entry
        };
        if (shouldUpdateRef.current && !shouldUpdateRef.current(next))
          return;
        if (!shouldUpdateRef.current && breakpoints && updateOnBreakpointChange) {
          setState(function(prev) {
            return prev.currentBreakpoint !== next.currentBreakpoint ? next : prev;
          });
          return;
        }
        setState(next);
      });
    });
    observe();
    return function() {
      unobserve();
      if (raf2)
        cancelAnimationFrame(raf2);
    };
  }, [
    // eslint-disable-next-line react-hooks/exhaustive-deps
    JSON.stringify(breakpoints),
    useBorderBoxSize,
    observe,
    unobserve,
    updateOnBreakpointChange
  ]);
  return _extends({}, state, {
    observe,
    unobserve
  });
};
var index_esm_default = useDimensions;

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match2 = regex.exec(ua);
    if (match2) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@thirdweb-dev/react/dist/index-aed60ee9.esm.js
var import_react_dom2 = __toESM(require_react_dom());
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
init_emotion_styled_browser_esm();
init_emotion_react_browser_esm();
var import_color = __toESM(require_color());
var import_FiCheck = __toESM(require_FiCheck());
var import_FiChevronDown = __toESM(require_FiChevronDown());
var import_FiCopy = __toESM(require_FiCopy());
var import_FiLock = __toESM(require_FiLock());
var import_FiShuffle = __toESM(require_FiShuffle());
var import_FiWifi = __toESM(require_FiWifi());
var import_FiXCircle = __toESM(require_FiXCircle());

// node_modules/@zag-js/anatomy/dist/chunk-JKTBQDTH.mjs
var createAnatomy = (name, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts2, ...values]),
  build: () => [...new Set(parts2)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/menu/dist/chunk-24OJ3KUG.mjs
var anatomy = createAnatomy("menu").parts(
  "trigger",
  "triggerItem",
  "positioner",
  "arrow",
  "arrowTip",
  "content",
  "separator",
  "item",
  "optionItem",
  "itemGroupLabel",
  "itemGroup"
);
var parts = anatomy.build();

// node_modules/@zag-js/menu/dist/chunk-QSWY67NH.mjs
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var add = (v, ...items) => v.concat(items);
var remove = (v, item) => removeAt(v, v.indexOf(item));
var removeAt = (v, i2) => {
  if (i2 > -1)
    v.splice(i2, 1);
  return v;
};
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  var _a;
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (_a = el == null ? void 0 : el.ownerDocument) != null ? _a : document;
}
function getWindow(el) {
  var _a;
  return (_a = el == null ? void 0 : el.ownerDocument.defaultView) != null ? _a : window;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a, _b;
      return (_b = (_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) != null ? _b : document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => {
      var _a;
      return (_a = dom2.getDoc(ctx).defaultView) != null ? _a : window;
    },
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
function contains(parent, child) {
  if (!parent)
    return false;
  return parent === child || isHTMLElement(parent) && isHTMLElement(child) && parent.contains(child);
}
function isHTMLElement(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
function isElementEditable(el) {
  if (el == null || !isHTMLElement(el)) {
    return false;
  }
  try {
    const win = getWindow(el);
    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
  } catch {
    return false;
  }
}
function queryAll(root, selector) {
  var _a;
  return Array.from((_a = root == null ? void 0 : root.querySelectorAll(selector)) != null ? _a : []);
}
function itemById(v, id) {
  return v.find((node) => node.id === id);
}
function indexOfId(v, id) {
  const item = itemById(v, id);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1)
    return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var getValueText = (item) => {
  var _a, _b;
  return (_b = (_a = item.dataset.valuetext) != null ? _a : item.textContent) != null ? _b : "";
};
var match = (valueText, query) => valueText.toLowerCase().startsWith(query.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function findByText(v, text, currentId) {
  const index = currentId ? indexOfId(v, currentId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => item.id !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
function findByTypeaheadImpl(_items, options) {
  const { state, activeId, key, timeout = 350 } = options;
  const search = state.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next = findByText(items, query, activeId);
  function cleanup() {
    clearTimeout(state.timer);
    state.timer = -1;
  }
  function update(value) {
    state.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var findByTypeahead = Object.assign(findByTypeaheadImpl, {
  defaultOptions: {
    keysSoFar: "",
    timer: -1
  },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var dom = defineDomHelpers({
  getTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.trigger) != null ? _b : `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.contextTrigger) != null ? _b : `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a, _b;
    return (_b = (_a = ctx.ids) == null ? void 0 : _a.content) != null ? _b : `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => `menu:${ctx.id}:arrow`,
  getPositionerId: (ctx) => `menu:${ctx.id}:popper`,
  getGroupId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.group) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = ctx.ids) == null ? void 0 : _a.label) == null ? void 0 : _b.call(_a, id)) != null ? _c : `menu:${ctx.id}:label:${id}`;
  },
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getFocusedItem: (ctx) => ctx.highlightedId ? dom.getById(ctx, ctx.highlightedId) : null,
  getArrowEl: (ctx) => dom.getById(ctx, dom.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom.getElements(ctx)),
  getLastEl: (ctx) => last(dom.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getPrevEl: (ctx, loop) => prevById(dom.getElements(ctx), ctx.highlightedId, loop != null ? loop : ctx.loop),
  getElemByKey: (ctx, key) => findByTypeahead(dom.getElements(ctx), { state: ctx.typeahead, key, activeId: ctx.highlightedId }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && v.dataset.disabled === "";
  },
  isTriggerItem: (el) => {
    var _a;
    return !!((_a = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  }
});

// node_modules/@zag-js/menu/dist/chunk-XVH4VTFY.mjs
var isArray = (v) => Array.isArray(v);
var isObject = (v) => !(v == null || typeof v !== "object" || isArray(v));
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  var _a;
  const agent = navigator.userAgentData;
  return (_a = agent == null ? void 0 : agent.platform) != null ? _a : navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^Mac/) && !isTouchDevice;
function getNativeEvent(e2) {
  var _a;
  return (_a = e2.nativeEvent) != null ? _a : e2;
}
function isSelfEvent(event) {
  return contains(event.currentTarget, event.target);
}
var supportsPointerEvent = () => isDom() && window.onpointerdown === null;
var supportsTouchEvent = () => isDom() && window.ontouchstart === null;
var supportsMouseEvent = () => isDom() && window.onmousedown === null;
var isTouchEvent = (v) => isObject(v) && hasProp(v, "touches");
var isLeftClick = (v) => v.button === 0;
var isContextMenuEvent = (e2) => {
  return e2.button === 2 || isCtrlKey(e2) && e2.button === 0;
};
var isModifiedEvent = (v) => v.ctrlKey || v.altKey || v.metaKey;
var isCtrlKey = (v) => isMac() ? v.metaKey && !v.ctrlKey : v.ctrlKey && !v.metaKey;
var fallback = {
  pageX: 0,
  pageY: 0,
  clientX: 0,
  clientY: 0
};
function getEventPoint(event, type = "page") {
  var _a, _b;
  const point2 = isTouchEvent(event) ? (_b = (_a = event.touches[0]) != null ? _a : event.changedTouches[0]) != null ? _b : fallback : event;
  return { x: point2[`${type}X`], y: point2[`${type}Y`] };
}

// node_modules/@zag-js/core/dist/chunk-UGUA3L77.mjs
var runIfFn = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res != null ? res : void 0;
};
var cast = (v) => v;
var noop3 = () => {
};
var callAll = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var uuid = (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();

// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var r = "a";
var n = "w";
var o = (e2, t2) => new Proxy(e2, t2);
var s = Object.getPrototypeOf;
var c = /* @__PURE__ */ new WeakMap();
var l = (e2) => e2 && (c.has(e2) ? c.get(e2) : s(e2) === Object.prototype || s(e2) === Array.prototype);
var f = (e2) => "object" == typeof e2 && null !== e2;
var i = /* @__PURE__ */ new WeakMap();
var a = (e2) => e2[t] || e2;
var u = (c2, f2, p2) => {
  if (!l(c2))
    return c2;
  const y = a(c2), g2 = ((e2) => Object.isFrozen(e2) || Object.values(Object.getOwnPropertyDescriptors(e2)).some((e3) => !e3.writable))(y);
  let h2 = p2 && p2.get(y);
  return h2 && h2[1].f === g2 || (h2 = ((o2, s2) => {
    const c3 = { f: s2 };
    let l2 = false;
    const f3 = (e2, t2) => {
      if (!l2) {
        let s3 = c3[r].get(o2);
        if (s3 || (s3 = {}, c3[r].set(o2, s3)), e2 === n)
          s3[n] = true;
        else {
          let r2 = s3[e2];
          r2 || (r2 = /* @__PURE__ */ new Set(), s3[e2] = r2), r2.add(t2);
        }
      }
    }, i2 = { get: (e2, n2) => n2 === t ? o2 : (f3("k", n2), u(Reflect.get(e2, n2), c3[r], c3.c)), has: (t2, n2) => n2 === e ? (l2 = true, c3[r].delete(o2), true) : (f3("h", n2), Reflect.has(t2, n2)), getOwnPropertyDescriptor: (e2, t2) => (f3("o", t2), Reflect.getOwnPropertyDescriptor(e2, t2)), ownKeys: (e2) => (f3(n), Reflect.ownKeys(e2)) };
    return s2 && (i2.set = i2.deleteProperty = () => false), [i2, c3];
  })(y, g2), h2[1].p = o(g2 ? ((e2) => {
    let t2 = i.get(e2);
    if (!t2) {
      if (Array.isArray(e2))
        t2 = Array.from(e2);
      else {
        const r2 = Object.getOwnPropertyDescriptors(e2);
        Object.values(r2).forEach((e3) => {
          e3.configurable = true;
        }), t2 = Object.create(s(e2), r2);
      }
      i.set(e2, t2);
    }
    return t2;
  })(y) : y, h2[0]), p2 && p2.set(y, h2)), h2[1][r] = f2, h2[1].c = p2, h2[1].p;
};
var p = (e2, t2, r2, o2) => {
  if (Object.is(e2, t2))
    return false;
  if (!f(e2) || !f(t2))
    return true;
  const s2 = r2.get(a(e2));
  if (!s2)
    return true;
  if (o2) {
    const r3 = o2.get(e2);
    if (r3 && r3.n === t2)
      return r3.g;
    o2.set(e2, { n: t2, g: false });
  }
  let c2 = null;
  try {
    for (const r3 of s2.h || [])
      if (c2 = Reflect.has(e2, r3) !== Reflect.has(t2, r3), c2)
        return c2;
    if (true === s2[n]) {
      if (c2 = ((e3, t3) => {
        const r3 = Reflect.ownKeys(e3), n2 = Reflect.ownKeys(t3);
        return r3.length !== n2.length || r3.some((e4, t4) => e4 !== n2[t4]);
      })(e2, t2), c2)
        return c2;
    } else
      for (const r3 of s2.o || [])
        if (c2 = !!Reflect.getOwnPropertyDescriptor(e2, r3) != !!Reflect.getOwnPropertyDescriptor(t2, r3), c2)
          return c2;
    for (const n2 of s2.k || [])
      if (c2 = p(e2[n2], t2[n2], r2, o2), c2)
        return c2;
    return null === c2 && (c2 = true), c2;
  } finally {
    o2 && o2.set(e2, { n: t2, g: c2 });
  }
};
var g = (e2) => l(e2) && e2[t] || null;
var h = (e2, t2 = true) => {
  c.set(e2, t2);
};
var w = (e2, t2, r2) => {
  const o2 = [], s2 = /* @__PURE__ */ new WeakSet(), c2 = (e3, l2) => {
    if (s2.has(e3))
      return;
    f(e3) && s2.add(e3);
    const i2 = f(e3) && t2.get(a(e3));
    if (i2) {
      var u2, p2;
      if (null == (u2 = i2.h) || u2.forEach((e4) => {
        const t3 = `:has(${String(e4)})`;
        o2.push(l2 ? [...l2, t3] : [t3]);
      }), true === i2[n]) {
        const e4 = ":ownKeys";
        o2.push(l2 ? [...l2, e4] : [e4]);
      } else {
        var y;
        null == (y = i2.o) || y.forEach((e4) => {
          const t3 = `:hasOwn(${String(e4)})`;
          o2.push(l2 ? [...l2, t3] : [t3]);
        });
      }
      null == (p2 = i2.k) || p2.forEach((t3) => {
        r2 && !("value" in (Object.getOwnPropertyDescriptor(e3, t3) || {})) || c2(e3[t3], l2 ? [...l2, t3] : [t3]);
      });
    } else
      l2 && o2.push(l2);
  };
  return c2(e2), o2;
};

// node_modules/@zag-js/store/dist/index.mjs
var __DEV__ = true;
var VERSION = Symbol();
var LISTENERS = Symbol();
var SNAPSHOT = Symbol();
var HANDLER = Symbol();
var PROMISE_RESULT = Symbol();
var PROMISE_ERROR = Symbol();
var refSet = /* @__PURE__ */ new WeakSet();
function ref(o2) {
  refSet.add(o2);
  return o2;
}
var isObject2 = (x) => typeof x === "object" && x !== null;
var canProxy = (x) => isObject2(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
var proxyCache = /* @__PURE__ */ new WeakMap();
var globalVersion = 1;
var snapshotCache = /* @__PURE__ */ new WeakMap();
function proxy(initialObject = {}) {
  if (!isObject2(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = globalVersion;
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++globalVersion) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = /* @__PURE__ */ new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const createSnapshot2 = (target, receiver) => {
    const cache = snapshotCache.get(receiver);
    if ((cache == null ? void 0 : cache[0]) === version) {
      return cache[1];
    }
    const snapshot2 = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    h(snapshot2, true);
    snapshotCache.set(receiver, [version, snapshot2]);
    Reflect.ownKeys(target).forEach((key) => {
      const value = Reflect.get(target, key, receiver);
      if (refSet.has(value)) {
        h(value, false);
        snapshot2[key] = value;
      } else if (value instanceof Promise) {
        if (PROMISE_RESULT in value) {
          snapshot2[key] = value[PROMISE_RESULT];
        } else {
          const errorOrPromise = value[PROMISE_ERROR] || value;
          Object.defineProperty(snapshot2, key, {
            get() {
              if (PROMISE_RESULT in value) {
                return value[PROMISE_RESULT];
              }
              throw errorOrPromise;
            }
          });
        }
      } else if (value == null ? void 0 : value[LISTENERS]) {
        snapshot2[key] = value[SNAPSHOT];
      } else {
        snapshot2[key] = value;
      }
    });
    Object.freeze(snapshot2);
    return snapshot2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }
      if (prop === LISTENERS) {
        return listeners;
      }
      if (prop === SNAPSHOT) {
        return createSnapshot2(target, receiver);
      }
      if (prop === HANDLER) {
        return handler;
      }
      return Reflect.get(target, prop, receiver);
    },
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    is: Object.is,
    canProxy,
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && this.is(prevValue, value)) {
        return true;
      }
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (isObject2(value)) {
        value = g(value) || value;
      }
      let nextValue;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) {
        nextValue = value;
      } else if (value instanceof Promise) {
        nextValue = value.then((v) => {
          nextValue[PROMISE_RESULT] = v;
          notifyUpdate(["resolve", [prop], v]);
          return v;
        }).catch((e2) => {
          nextValue[PROMISE_ERROR] = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else if (value == null ? void 0 : value[LISTENERS]) {
        nextValue = value;
        nextValue[LISTENERS].add(getPropListener(prop));
      } else if (this.canProxy(value)) {
        nextValue = proxy(value);
        nextValue[LISTENERS].add(getPropListener(prop));
      } else {
        nextValue = value;
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = new Proxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}
function subscribe(proxyObject, callback, notifyInSync) {
  if (__DEV__ && !(proxyObject == null ? void 0 : proxyObject[LISTENERS])) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        callback(ops.splice(0));
      });
    }
  };
  proxyObject[LISTENERS].add(listener);
  return () => {
    ;
    proxyObject[LISTENERS].delete(listener);
  };
}
function snapshot(proxyObject) {
  if (__DEV__ && !(proxyObject == null ? void 0 : proxyObject[SNAPSHOT])) {
    console.warn("Please use proxy object");
  }
  return proxyObject[SNAPSHOT];
}
function proxyWithComputed(initialObject, computedFns) {
  ;
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set2 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set2) {
      desc.set = (newValue) => set2(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

// node_modules/@zag-js/core/dist/chunk-OEYKD4DX.mjs
function createProxy(config) {
  var _a, _b;
  const computedContext = (_a = config.computed) != null ? _a : cast({});
  const initialContext = (_b = config.context) != null ? _b : cast({});
  const state = proxy({
    value: "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a2, _b2, _c, _d;
      const stateEvents = (_c = (_b2 = (_a2 = config.states) == null ? void 0 : _a2[this.value]) == null ? void 0 : _b2["on"]) != null ? _c : {};
      const globalEvents = (_d = config == null ? void 0 : config.on) != null ? _d : {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue)
        return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state);
}

// node_modules/@zag-js/core/dist/chunk-I7UKD6FS.mjs
var isDev = () => true;
var isArray2 = (v) => Array.isArray(v);
var isObject3 = (v) => !(v == null || typeof v !== "object" || isArray2(v));
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";

// node_modules/@zag-js/core/dist/chunk-WGX76W7X.mjs
function compact(obj) {
  if (obj === void 0)
    return obj;
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0).map(([key, value]) => [key, isObject3(value) ? compact(value) : value])
  );
}
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact(obj);
    for (const key in target) {
      if (isObject3(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}

// node_modules/@zag-js/core/dist/chunk-ODMF3BNU.mjs
function warn(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c2 = a2.length === 2 ? a2[0] : true;
  if (c2 && true) {
    console.warn(m);
  }
}
function invariant2(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c2 = a2.length === 2 ? a2[0] : true;
  if (c2 && true) {
    throw new Error(m);
  }
}
function determineDelayFn(delay, delaysMap) {
  return (context, event) => {
    if (isNumber(delay))
      return delay;
    if (isFunction(delay)) {
      return delay(context, event);
    }
    if (isString(delay)) {
      const value = Number.parseFloat(delay);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay];
        invariant2(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}

// node_modules/klona/full/index.mjs
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i2 = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i2 < list.length; i2++) {
      set(tmp, list[i2], Object.getOwnPropertyDescriptor(x, list[i2]));
    }
    for (i2 = 0, list = Object.getOwnPropertyNames(x); i2 < list.length; i2++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i2]) && tmp[k] === x[k])
        continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}

// node_modules/klona/json/index.mjs
function klona2(val) {
  var k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--)
      out[k] = (tmp = val[k]) && typeof tmp === "object" ? klona2(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: klona2(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? klona2(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}

// node_modules/@zag-js/core/dist/chunk-56JGUX4Y.mjs
function cloneJson(v) {
  return klona2(v);
}
function cloneFull(v) {
  return klona(v);
}
function toEvent(event) {
  const obj = isString(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value)
    return [];
  return isArray2(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject3(value) && value.predicate != null;
}
var defaultCompareFn = (prev, next) => Object.is(prev, next);
function subscribeKey(obj, key, fn, sync, compareFn) {
  let prev = Reflect.get(snapshot(obj), key);
  const isEqual2 = compareFn || defaultCompareFn;
  return subscribe(
    obj,
    function onSnapshotChange() {
      const snap = snapshot(obj);
      if (!isEqual2(prev, snap[key], key)) {
        fn(snap[key]);
        prev = Reflect.get(snap, key);
      }
    },
    sync
  );
}

// node_modules/@zag-js/core/dist/chunk-SHFNMZGG.mjs
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a;
    if (isString(guard)) {
      return !!((_a = guardMap[guard]) == null ? void 0 : _a.call(guardMap, ctx, event, meta));
    }
    if (isFunction(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };
function determineGuardFn(guard, guardMap) {
  guard = guard != null ? guard : Truthy;
  return (context, event, meta) => {
    if (isString(guard)) {
      const value = guardMap[guard];
      return isFunction(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}

// node_modules/@zag-js/core/dist/chunk-PXYNHVJE.mjs
function toTarget(target) {
  return isString(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      var _a;
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return (_a = guard != null ? guard : transition.target) != null ? _a : transition.actions;
    });
  };
}

// node_modules/@zag-js/core/dist/chunk-NHABU752.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/@zag-js/core/dist/chunk-IU53N4Y4.mjs
function clear(v) {
  while (v.length > 0)
    v.pop();
  return v;
}
var Machine = class {
  constructor(config, options) {
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextListeners", /* @__PURE__ */ new Set());
    __publicField(this, "eventListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop3);
    __publicField(this, "removeEventListener", noop3);
    __publicField(this, "removeContextListener", noop3);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "start", (init) => {
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.removeEventListener = subscribeKey(
        this.state,
        "event",
        (event22) => {
          this.executeActions(this.config.onEvent, event22);
          this.eventListeners.forEach((listener) => {
            listener(event22);
          });
        },
        this.sync
      );
      this.removeContextListener = subscribe(
        this.state.context,
        () => {
          this.log("Context:", this.contextSnapshot);
          this.contextListeners.forEach((listener) => {
            listener(this.contextSnapshot);
          });
        },
        this.sync || this.options.debug
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event2 = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject3(init) ? init.value : init;
      const context = isObject3(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target != null ? target : this.config.initial
      };
      const next = this.getNextStateInfo(transition, event2);
      this.initialState = next;
      this.performStateChangeEffects(this.state.value, next, event2);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      var _a2, _b2;
      for (const [key, fn] of Object.entries((_a2 = this.config.watch) != null ? _a2 : {})) {
        let cleanup;
        if (key === "*") {
          cleanup = subscribe(this.state.context, () => {
            this.executeActions(fn, this.state.event);
          });
        } else {
          const compareFn = (_b2 = this.options.compareFns) == null ? void 0 : _b2[key];
          cleanup = subscribeKey(
            this.state.context,
            key,
            () => {
              this.executeActions(fn, this.state.event);
            },
            this.sync,
            compareFn
          );
        }
        this.contextWatchers.add(cleanup);
      }
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped")
        return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.stopEventListeners();
      this.stopContextListeners();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopEventListeners", () => {
      this.eventListeners.clear();
      this.removeEventListener();
    });
    __publicField(this, "stopContextListeners", () => {
      this.contextListeners.clear();
      this.removeContextListener();
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state) => {
        state.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state) => {
      var _a2, _b2;
      if (state) {
        (_a2 = this.activityEvents.get(state)) == null ? void 0 : _a2.forEach((stop) => stop());
        (_b2 = this.activityEvents.get(state)) == null ? void 0 : _b2.clear();
        this.activityEvents.delete(state);
      } else {
        this.activityEvents.forEach((state2) => {
          state2.forEach((stop) => stop());
          state2.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event2 = toEvent(evt);
      const id = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant2(`[@zag-js/core] Cannot send '${event2.type}' event to unknown child`);
      }
      child.send(event2);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant2(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn(src);
      if (id)
        actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField(this, "addActivityCleanup", (state, cleanup) => {
      var _a2;
      if (!state)
        return;
      if (!this.activityEvents.has(state)) {
        this.activityEvents.set(state, /* @__PURE__ */ new Set([cleanup]));
      } else {
        (_a2 = this.activityEvents.get(state)) == null ? void 0 : _a2.add(cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "setContext", (context) => {
      if (!context)
        return;
      deepMerge(this.state.context, context);
    });
    __publicField(this, "withContext", (context) => {
      const newContext = { ...this.config.context, ...compact(context) };
      return new Machine({ ...this.config, context: newContext }, this.options);
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state) => {
      var _a2;
      if (!state)
        return;
      return (_a2 = this.config.states) == null ? void 0 : _a2[state];
    });
    __publicField(this, "getNextStateInfo", (transitions, event2) => {
      var _a2;
      const transition = this.determineTransition(transitions, event2);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (_a2 = transition == null ? void 0 : transition.target) != null ? _a2 : this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event2.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getActionFromDelayedTransition", (transition) => {
      const event2 = toEvent(
        "machine.after"
        /* After */
      );
      const determineDelay = determineDelayFn(transition.delay, this.delayMap);
      const delay = determineDelay(this.contextSnapshot, event2);
      let id;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next = this.getNextStateInfo(transition, event2);
            this.performStateChangeEffects(this.state.value, next, event2);
          }, delay);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state) => {
      const stateNode = this.getStateNode(state);
      const event2 = toEvent(
        "machine.after"
        /* After */
      );
      if (!stateNode || !stateNode.after)
        return;
      const entries = [];
      const exits = [];
      if (isArray2(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event2);
        if (!transition)
          return;
        const actions = this.getActionFromDelayedTransition(transition);
        entries.push(actions.entry);
        exits.push(actions.exit);
      } else if (isObject3(stateNode.after)) {
        for (const delay in stateNode.after) {
          const transition = stateNode.after[delay];
          let resolvedTransition = {};
          if (isArray2(transition)) {
            const picked = this.determineTransition(transition, event2);
            if (picked)
              resolvedTransition = picked;
          } else if (isString(transition)) {
            resolvedTransition = { target: transition, delay };
          } else {
            resolvedTransition = { ...transition, delay };
          }
          const actions = this.getActionFromDelayedTransition(resolvedTransition);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event2) => {
      var _a2;
      const _actions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event2, this.guardMeta);
      for (const action of toArray(_actions)) {
        const fn = isString(action) ? (_a2 = this.actionMap) == null ? void 0 : _a2[action] : action;
        warn(
          isString(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event2, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event2, activities, state) => {
      var _a2;
      for (const activity of activities) {
        const fn = isString(activity) ? (_a2 = this.activityMap) == null ? void 0 : _a2[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event2, this.meta);
        if (cleanup) {
          this.addActivityCleanup(state != null ? state : this.state.value, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every)
        return;
      const event2 = toEvent(
        "machine.every"
        /* Every */
      );
      if (isArray2(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay2 = determineDelay2(this.contextSnapshot, event2);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, event2, this.guardMeta);
          return guard != null ? guard : delay2 != null;
        });
        if (!picked)
          return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay = determineDelay(this.contextSnapshot, event2);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, event2);
          }, delay);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay = determineDelay(this.contextSnapshot, event2);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, event2);
            }, delay);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event2) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event2));
    });
    __publicField(this, "performExitEffects", (current, event2) => {
      const currentState = this.state.value;
      if (currentState === "")
        return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event2, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event2);
      this.eventListeners.clear();
    });
    __publicField(this, "performEntryEffects", (next, event2) => {
      const stateNode = this.getStateNode(next);
      const activities = toArray(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event2, activities);
      }
      const _entry = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(this.contextSnapshot, event2, this.guardMeta);
      const entryActions = toArray(_entry);
      const afterActions = this.getDelayedEventActions(next);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event2);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event2) => {
      const transition = this.determineTransition(transitions, event2);
      this.executeActions(transition == null ? void 0 : transition.actions, event2);
    });
    __publicField(this, "performStateChangeEffects", (current, next, event2) => {
      this.setEvent(event2);
      const changed = next.changed || next.reenter;
      if (changed) {
        this.performExitEffects(current, event2);
      }
      this.performTransitionEffects(next.transition, event2);
      this.setState(next.target);
      if (changed) {
        this.performEntryEffects(next.target, event2);
      }
    });
    __publicField(this, "determineTransition", (transition, event2) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event2, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a2;
      if (!this.parent) {
        invariant2("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event2 = toEvent(evt);
      (_a2 = this.parent) == null ? void 0 : _a2.send(event2);
    });
    __publicField(this, "log", (...args) => {
      if (isDev() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event2 = toEvent(evt);
      this.transition(this.state.value, event2);
    });
    __publicField(this, "transition", (state, evt) => {
      var _a2, _b2, _c2;
      const stateNode = isString(state) ? this.getStateNode(state) : state == null ? void 0 : state.stateNode;
      const event2 = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state}, \`event\`: ${event2.type}`;
        warn(msg);
        return;
      }
      const transitions = (_c2 = (_a2 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a2[event2.type]) != null ? _c2 : (_b2 = this.config.on) == null ? void 0 : _b2[event2.type];
      const next = this.getNextStateInfo(transitions, event2);
      this.performStateChangeEffects(this.state.value, next, event2);
      return next.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    __publicField(this, "onChange", (listener) => {
      this.contextListeners.add(listener);
      return this;
    });
    __publicField(this, "onEvent", (listener) => {
      this.eventListeners.add(listener);
      return this;
    });
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    this.config = cloneFull(config);
    this.options = cloneFull(options != null ? options : {});
    this.id = (_a = this.config.id) != null ? _a : `machine-${uuid()}`;
    this.guardMap = (_c = (_b = this.options) == null ? void 0 : _b.guards) != null ? _c : {};
    this.actionMap = (_e = (_d = this.options) == null ? void 0 : _d.actions) != null ? _e : {};
    this.delayMap = (_g = (_f = this.options) == null ? void 0 : _f.delays) != null ? _g : {};
    this.activityMap = (_i = (_h = this.options) == null ? void 0 : _h.activities) != null ? _i : {};
    this.sync = (_k = (_j = this.options) == null ? void 0 : _j.sync) != null ? _k : false;
    this.state = createProxy(this.config);
    const event = toEvent(
      "machine.created"
      /* Created */
    );
    this.executeActions((_l = this.config) == null ? void 0 : _l.created, event);
  }
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return cloneJson(this.stateSnapshot);
  }
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  get self() {
    const _self = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      get state() {
        return _self.stateSnapshot;
      }
    };
  }
  get meta() {
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
};
var createMachine = (config, options) => new Machine(config, options);

// node_modules/@zag-js/core/dist/chunk-HLI3BEOP.mjs
var MachineStatus = ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Running"] = "Running";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var ActionTypes = ((ActionTypes2) => {
  ActionTypes2["Start"] = "machine.start";
  ActionTypes2["Stop"] = "machine.stop";
  ActionTypes2["Created"] = "machine.created";
  ActionTypes2["SendParent"] = "machine.send-parent";
  ActionTypes2["After"] = "machine.after";
  ActionTypes2["Every"] = "machine.every";
  ActionTypes2["Init"] = "machine.init";
  return ActionTypes2;
})(ActionTypes || {});
var MachineType = ((MachineType2) => {
  MachineType2["Machine"] = "machine";
  MachineType2["Actor"] = "machine.actor";
  return MachineType2;
})(MachineType || {});

// node_modules/@zag-js/core/dist/chunk-VIU3KWFE.mjs
var clsx = (...args) => args.map((str) => str == null ? void 0 : str.trim()).filter(Boolean).join(" ");
function mergeProps(...args) {
  var _a, _b;
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (/^on[A-Z]/.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll(result[key], props[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, (_a = result[key]) != null ? _a : {}, (_b = props[key]) != null ? _b : {});
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}

// node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min3 ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min3 ? min3 - center : max3 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(state) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const axis = getMainAxisFromPlacement(placement);
      const isXAxis = axis === "x";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isXAxis) {
        availableWidth = min(
          // Maximum clipping viewport width
          width - overflow.right - overflow.left,
          overflowAvailableWidth
        );
      } else {
        availableHeight = min(
          // Maximum clipping viewport height
          height - overflow.bottom - overflow.top,
          overflowAvailableHeight
        );
      }
      if (!state.middlewareData.shift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isXAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs
function getWindow2(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "";
}
var uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
    return uaString;
  }
  return navigator.userAgent;
}
function isHTMLElement2(value) {
  return value instanceof getWindow2(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow2(value).Element;
}
function isNode(value) {
  return value instanceof getWindow2(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow2(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;
  return css.transform !== "none" || css.perspective !== "none" || (backdropFilter ? backdropFilter !== "none" : false) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective"].some((value) => css.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some(
    // TS 4.1 compat
    (value) => {
      const contain = css.contain;
      return contain != null ? contain.includes(value) : false;
    }
  );
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const offsetWidth = element.offsetWidth;
  const offsetHeight = element.offsetHeight;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback: fallback3
  } = getCssDimensions(domElement);
  let x = (fallback3 ? round(rect.width) : rect.width) / width;
  let y = (fallback3 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow2(domElement) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow2(currentIFrame).frameElement;
    }
  }
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === "fixed", offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node
    node.assignedSlot || // DOM Element detected
    node.parentNode || // ShadowRoot detected
    (isShadowRoot(node) ? node.host : null) || // Fallback
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement2(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow2(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y,
    width,
    height
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  if (clippingAncestor === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingAncestor)) {
    return getInnerBoundingClientRect(clippingAncestor, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/chunk-MDQJEIPL.mjs
var runIfFn2 = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res != null ? res : void 0;
};
var callAll2 = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var isBoolean = (v) => v === true || v === false;
var hasProp2 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function isHTMLElement3(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
var isRef = (v) => hasProp2(v, "current");
function addDomEvent(target, eventName, handler, options) {
  const node = isRef(target) ? target.current : runIfFn2(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
function getObservedElements() {
  ;
  globalThis.__rectObserverMap__ = globalThis.__rectObserverMap__ || /* @__PURE__ */ new Map();
  return globalThis.__rectObserverMap__;
}
function observeElementRect(el, fn) {
  const observedElements = getObservedElements();
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, { rect: {}, callbacks: [fn] });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(runLoop);
    }
  } else {
    data.callbacks.push(fn);
    fn(el.getBoundingClientRect());
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2)
      return;
    const index = data2.callbacks.indexOf(fn);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
var rafId;
function runLoop() {
  const observedElements = getObservedElements();
  const changedRectsData = [];
  observedElements.forEach((data, element) => {
    const newRect = element.getBoundingClientRect();
    if (!isEqual(data.rect, newRect)) {
      data.rect = newRect;
      changedRectsData.push(data);
    }
  });
  changedRectsData.forEach((data) => {
    data.callbacks.forEach((callback) => callback(data.rect));
  });
  rafId = requestAnimationFrame(runLoop);
}
function isEqual(rect1, rect2) {
  return rect1.width === rect2.width && rect1.height === rect2.height && rect1.top === rect2.top && rect1.right === rect2.right && rect1.bottom === rect2.bottom && rect1.left === rect2.left;
}
function resolveOptions(option) {
  var _a, _b, _c;
  const bool = isBoolean(option);
  return {
    ancestorResize: bool ? option : (_a = option.ancestorResize) != null ? _a : true,
    ancestorScroll: bool ? option : (_b = option.ancestorScroll) != null ? _b : true,
    referenceResize: bool ? option : (_c = option.referenceResize) != null ? _c : true
  };
}
function autoUpdate(reference, floating, update, options = false) {
  const { ancestorScroll, ancestorResize, referenceResize } = resolveOptions(options);
  const useAncestors = ancestorScroll || ancestorResize;
  const ancestors = [];
  if (useAncestors && isHTMLElement3(reference)) {
    ancestors.push(...getOverflowAncestors(reference));
  }
  function addResizeListeners() {
    let cleanups = [observeElementRect(floating, update)];
    if (referenceResize && isHTMLElement3(reference)) {
      cleanups.push(observeElementRect(reference, update));
    }
    cleanups.push(callAll2(...ancestors.map((el) => addDomEvent(el, "resize", update))));
    return () => cleanups.forEach((fn) => fn());
  }
  function addScrollListeners() {
    return callAll2(...ancestors.map((el) => addDomEvent(el, "scroll", update, { passive: true })));
  }
  return callAll2(addResizeListeners(), addScrollListeners());
}

// node_modules/@zag-js/popper/dist/chunk-X5LLREVI.mjs
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOrigin = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin2 = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin2);
    return {
      data: { transformOrigin: transformOrigin2 }
    };
  }
};
var shiftArrow = (opts) => ({
  name: "shiftArrow",
  fn({ placement, middlewareData }) {
    const { element: arrow2 } = opts;
    if (middlewareData.arrow) {
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrow2.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
    }
    return {};
  }
});

// node_modules/@zag-js/popper/dist/chunk-7DJY6BDG.mjs
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  sameWidth: false,
  overflowPadding: 8
};
function getPlacement(reference, floating, opts = {}) {
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [];
  const boundary = typeof options.boundary === "function" ? options.boundary() : options.boundary;
  if (options.flip) {
    middleware.push(
      flip({
        boundary,
        padding: options.overflowPadding
      })
    );
  }
  if (options.gutter || options.offset) {
    const arrowOffset = arrowEl ? arrowEl.offsetHeight / 2 : 0;
    const data = options.gutter ? { mainAxis: options.gutter } : options.offset;
    if ((data == null ? void 0 : data.mainAxis) != null)
      data.mainAxis += arrowOffset;
    middleware.push(offset(data));
  }
  middleware.push(
    shift({
      boundary,
      crossAxis: options.overlap,
      padding: options.overflowPadding
    })
  );
  if (arrowEl) {
    middleware.push(
      arrow({ element: arrowEl, padding: 8 }),
      shiftArrow({ element: arrowEl })
    );
  }
  middleware.push(transformOrigin);
  middleware.push(
    size({
      padding: options.overflowPadding,
      apply({ rects, availableHeight, availableWidth }) {
        const referenceWidth = Math.round(rects.reference.width);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
        if (options.sameWidth) {
          Object.assign(floating.style, {
            width: `${referenceWidth}px`,
            minWidth: "unset"
          });
        }
        if (options.fitViewport) {
          Object.assign(floating.style, {
            maxWidth: `${availableWidth}px`,
            maxHeight: `${availableHeight}px`
          });
        }
      }
    })
  );
  function compute(config = {}) {
    if (!reference || !floating)
      return;
    const { placement, strategy } = options;
    computePosition2(reference, floating, {
      placement,
      middleware,
      strategy,
      ...config
    }).then((data) => {
      var _a;
      const x = Math.round(data.x);
      const y = Math.round(data.y);
      Object.assign(floating.style, {
        position: data.strategy,
        top: "0",
        left: "0",
        transform: `translate3d(${x}px, ${y}px, 0)`
      });
      (_a = options.onComplete) == null ? void 0 : _a.call(options, { ...data, compute });
    });
  }
  compute();
  return callAll2(
    options.listeners ? autoUpdate(reference, floating, compute, options.listeners) : void 0,
    options.onCleanup
  );
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@zag-js/popper/dist/chunk-I46LTIWB.mjs
var UNMEASURED_FLOATING_STYLE = {
  position: "fixed",
  top: 0,
  left: 0,
  opacity: 0,
  transform: "translate3d(0, -200%, 0)",
  pointerEvents: "none"
};
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options) {
  const { measured, strategy = "absolute", placement = "bottom" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`,
      opacity: !measured ? 0 : void 0
    },
    arrowTip: {
      transform: ARROW_FLOATING_STYLE[placement.split("-")[0]],
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      minWidth: "max-content",
      ...!measured && UNMEASURED_FLOATING_STYLE
    }
  };
}

// node_modules/@zag-js/menu/dist/chunk-52I5JMVQ.mjs
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
var sameKeyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
function getEventKey(event, options = {}) {
  var _a;
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = (_a = sameKeyMap[key]) != null ? _a : key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function connect(state, send, normalize) {
  var _a;
  const isSubmenu = state.context.isSubmenu;
  const values = state.context.value;
  const isTypingAhead = state.context.isTypingAhead;
  const isOpen = state.hasTag("visible");
  const popperStyles = getPlacementStyles({
    measured: !!state.context.anchorPoint || !!state.context.currentPlacement,
    placement: state.context.currentPlacement
  });
  const api = {
    isOpen,
    open() {
      send("OPEN");
    },
    close() {
      send("CLOSE");
    },
    highlightedId: state.context.highlightedId,
    setHighlightedId(id) {
      send({ type: "SET_HIGHLIGHTED_ID", id });
    },
    setParent(parent) {
      send({ type: "SET_PARENT", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "SET_CHILD", value: child, id: child.state.context.id });
    },
    value: values,
    setValue(name, value) {
      send({ type: "SET_VALUE", name, value });
    },
    isOptionChecked(opts) {
      return opts.type === "radio" ? (values == null ? void 0 : values[opts.name]) === opts.value : values == null ? void 0 : values[opts.name].includes(opts.value);
    },
    contextTriggerProps: normalize.element({
      ...parts.trigger.attrs,
      id: dom.getContextTriggerId(state.context),
      onPointerDown(event) {
        if (event.pointerType === "mouse")
          return;
        const evt = getNativeEvent(event);
        send({ type: "CONTEXT_MENU_START", point: getEventPoint(evt) });
      },
      onPointerCancel(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerMove(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onPointerUp(event) {
        if (event.pointerType === "mouse")
          return;
        send("CONTEXT_MENU_CANCEL");
      },
      onContextMenu(event) {
        const evt = getNativeEvent(event);
        send({ type: "CONTEXT_MENU", point: getEventPoint(evt) });
        event.preventDefault();
      },
      style: {
        WebkitTouchCallout: "none",
        userSelect: "none"
      }
    }),
    getTriggerItemProps(childApi) {
      return mergeProps(api.getItemProps({ id: childApi.triggerProps.id }), childApi.triggerProps);
    },
    triggerProps: normalize.button({
      ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
      "data-placement": state.context.currentPlacement,
      type: "button",
      dir: state.context.dir,
      id: dom.getTriggerId(state.context),
      "data-uid": state.context.id,
      "aria-haspopup": "menu",
      "aria-controls": dom.getContentId(state.context),
      "aria-expanded": isOpen || void 0,
      "data-expanded": dataAttr(isOpen),
      onPointerMove(event) {
        if (event.pointerType !== "mouse")
          return;
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({
          type: "TRIGGER_POINTERMOVE",
          target: event.currentTarget
        });
      },
      onPointerLeave(event) {
        if (event.pointerType !== "mouse")
          return;
        const evt = getNativeEvent(event);
        const disabled = dom.isTargetDisabled(event.currentTarget);
        if (disabled || !isSubmenu)
          return;
        send({
          type: "TRIGGER_POINTERLEAVE",
          target: event.currentTarget,
          point: getEventPoint(evt)
        });
      },
      onClick(event) {
        if (dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onPointerDown(event) {
        const disabled = dom.isTargetDisabled(event.currentTarget);
        const evt = getNativeEvent(event);
        if (!isLeftClick(evt) || disabled || isContextMenuEvent(event))
          return;
        event.preventDefault();
        if (!dom.isTriggerItem(event.currentTarget)) {
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        }
      },
      onBlur() {
        send("TRIGGER_BLUR");
      },
      onFocus() {
        send("TRIGGER_FOCUS");
      },
      onKeyDown(event) {
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          Enter() {
            send({ type: "ARROW_DOWN" });
          },
          Space() {
            send({ type: "ARROW_DOWN" });
          }
        };
        const key = getEventKey(event, state.context);
        const exec2 = keyMap[key];
        if (exec2) {
          event.preventDefault();
          exec2(event);
        }
      }
    }),
    positionerProps: normalize.element({
      ...parts.positioner.attrs,
      id: dom.getPositionerId(state.context),
      style: popperStyles.floating
    }),
    arrowProps: normalize.element({
      id: dom.getArrowId(state.context),
      ...parts.arrow.attrs,
      style: popperStyles.arrow
    }),
    arrowTipProps: normalize.element({
      ...parts.arrowTip.attrs,
      style: popperStyles.arrowTip
    }),
    contentProps: normalize.element({
      ...parts.content.attrs,
      id: dom.getContentId(state.context),
      "aria-label": state.context["aria-label"],
      hidden: !isOpen,
      role: "menu",
      tabIndex: 0,
      dir: state.context.dir,
      "aria-activedescendant": (_a = state.context.highlightedId) != null ? _a : void 0,
      "aria-labelledby": dom.getTriggerId(state.context),
      "data-placement": state.context.currentPlacement,
      onPointerEnter(event) {
        if (event.pointerType !== "mouse")
          return;
        send("MENU_POINTERENTER");
      },
      onKeyDown(event) {
        if (!isSelfEvent(event))
          return;
        const item = dom.getFocusedItem(state.context);
        const isLink = !!(item == null ? void 0 : item.matches("a[href]"));
        const keyMap = {
          ArrowDown() {
            send("ARROW_DOWN");
          },
          ArrowUp() {
            send("ARROW_UP");
          },
          ArrowLeft() {
            send("ARROW_LEFT");
          },
          ArrowRight() {
            send("ARROW_RIGHT");
          },
          Enter() {
            if (isLink)
              item == null ? void 0 : item.click();
            send("ENTER");
          },
          Space(event2) {
            var _a2;
            if (isTypingAhead) {
              send({ type: "TYPEAHEAD", key: event2.key });
            } else {
              (_a2 = keyMap.Enter) == null ? void 0 : _a2.call(keyMap, event2);
            }
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          },
          Tab(event2) {
            send({ type: "TAB", shiftKey: event2.shiftKey, loop: false });
          }
        };
        const key = getEventKey(event, { dir: state.context.dir });
        const exec2 = keyMap[key];
        if (exec2) {
          const allow = isLink && key === "Enter";
          exec2(event);
          if (!allow) {
            event.preventDefault();
          }
        } else {
          const isSingleKey = event.key.length === 1;
          const isValidTypeahead = isSingleKey && !isModifiedEvent(event) && !isElementEditable(item);
          if (!isValidTypeahead)
            return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      }
    }),
    separatorProps: normalize.element({
      ...parts.separator.attrs,
      role: "separator",
      "aria-orientation": "horizontal"
    }),
    getItemProps(options) {
      const { id, disabled, valueText } = options;
      return normalize.element({
        ...parts.item.attrs,
        id,
        role: "menuitem",
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-ownedby": dom.getContentId(state.context),
        "data-focus": dataAttr(state.context.highlightedId === id),
        "data-valuetext": valueText,
        onClick(event) {
          if (disabled)
            return;
          send({ type: "ITEM_CLICK", target: event.currentTarget, id });
        },
        onPointerDown(event) {
          if (disabled)
            return;
          send({ type: "ITEM_POINTERDOWN", target: event.currentTarget, id });
        },
        onPointerUp(event) {
          const evt = getNativeEvent(event);
          if (!isLeftClick(evt) || disabled || state.context.pointerdownNode === event.currentTarget)
            return;
          event.currentTarget.click();
        },
        onPointerLeave(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERLEAVE", target: event.currentTarget });
        },
        onPointerMove(event) {
          if (disabled || event.pointerType !== "mouse")
            return;
          send({ type: "ITEM_POINTERMOVE", id, target: event.currentTarget });
        },
        onDragStart(event) {
          const isLink = event.currentTarget.matches("a[href]");
          if (isLink)
            event.preventDefault();
        },
        onAuxClick(event) {
          if (disabled)
            return;
          event.preventDefault();
          event.currentTarget.click();
        }
      });
    },
    getOptionItemProps(option) {
      var _a2, _b;
      const { name, type, disabled, onCheckedChange } = option;
      (_a2 = option.id) != null ? _a2 : option.id = option.value;
      (_b = option.valueText) != null ? _b : option.valueText = option.value;
      const checked = api.isOptionChecked(option);
      return Object.assign(
        api.getItemProps(option),
        normalize.element({
          "data-type": type,
          "data-name": name,
          ...parts.optionItem.attrs,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!checked,
          "data-checked": dataAttr(checked),
          onClick(event) {
            if (disabled)
              return;
            send({ type: "ITEM_CLICK", target: event.currentTarget, option });
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        })
      );
    },
    getItemGroupLabelProps(options) {
      return normalize.element({
        id: dom.getGroupLabelId(state.context, options.htmlFor),
        ...parts.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(options) {
      return normalize.element({
        id: dom.getGroupId(state.context, options.id),
        ...parts.itemGroup.attrs,
        "aria-labelledby": options.id,
        role: "group"
      });
    }
  };
  return api;
}

// node_modules/@zag-js/dismissable/dist/chunk-3ZVQOINJ.mjs
var runIfFn3 = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res != null ? res : void 0;
};
var hasProp3 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var isRef2 = (v) => hasProp3(v, "current");
function addDomEvent2(target, eventName, handler, options) {
  const node = isRef2(target) ? target.current : runIfFn3(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
function trackEscapeKeydown(fn) {
  const handleKeyDown = (event) => {
    if (event.key === "Escape")
      fn == null ? void 0 : fn(event);
  };
  return addDomEvent2(document, "keydown", handleKeyDown);
}

// node_modules/@zag-js/dismissable/dist/chunk-PFLX3TD5.mjs
function isDocument2(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow2(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument2(el) {
  var _a;
  if (isWindow2(el))
    return el.document;
  if (isDocument2(el))
    return el;
  return (_a = el == null ? void 0 : el.ownerDocument) != null ? _a : document;
}
function getEventTarget(event) {
  var _a, _b;
  return (_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)[0]) != null ? _b : event.target;
}
function contains2(parent, child) {
  if (!parent)
    return false;
  return parent === child || isHTMLElement4(parent) && isHTMLElement4(child) && parent.contains(child);
}
function isHTMLElement4(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    var _a;
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a = this.topMostPointerBlockingLayer()) == null ? void 0 : _a.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains2(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains2(branch, target));
  },
  add(layer) {
    this.layers.push(layer);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0)
      return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0)
      this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    var _a;
    (_a = this.layers[this.indexOf(node)]) == null ? void 0 : _a.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};

// node_modules/@zag-js/dismissable/dist/chunk-6YFBZALL.mjs
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
var DATA_ATTR = "data-inert";
function disablePointerEventsOutside(node) {
  const doc = getDocument2(node);
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute(DATA_ATTR)) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    doc.body.style.pointerEvents = "none";
    doc.body.setAttribute(DATA_ATTR, "");
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer())
      return;
    doc.body.style.pointerEvents = originalBodyPointerEvents;
    doc.body.removeAttribute(DATA_ATTR);
    if (doc.body.style.length === 0)
      doc.body.removeAttribute("style");
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
var runIfFn4 = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res != null ? res : void 0;
};
var callAll3 = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var hasProp4 = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var isDom2 = () => typeof window !== "undefined";
function getPlatform2() {
  var _a;
  const agent = navigator.userAgentData;
  return (_a = agent == null ? void 0 : agent.platform) != null ? _a : navigator.platform;
}
var pt2 = (v) => isDom2() && v.test(getPlatform2());
var isTouchDevice2 = () => isDom2() && !!navigator.maxTouchPoints;
var isMac2 = () => pt2(/^Mac/) && !isTouchDevice2;
function isDocument3(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow3(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument3(el) {
  var _a;
  if (isWindow3(el))
    return el.document;
  if (isDocument3(el))
    return el;
  return (_a = el == null ? void 0 : el.ownerDocument) != null ? _a : document;
}
function getWindow3(el) {
  var _a;
  return (_a = el == null ? void 0 : el.ownerDocument.defaultView) != null ? _a : window;
}
function getEventTarget2(event) {
  var _a, _b;
  return (_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)[0]) != null ? _b : event.target;
}
function contains3(parent, child) {
  if (!parent)
    return false;
  return parent === child || isHTMLElement5(parent) && isHTMLElement5(child) && parent.contains(child);
}
function isHTMLElement5(v) {
  return typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
}
function isVisible(el) {
  if (!isHTMLElement5(el))
    return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
var isContextMenuEvent2 = (e2) => {
  return e2.button === 2 || isCtrlKey2(e2) && e2.button === 0;
};
var isCtrlKey2 = (v) => isMac2() ? v.metaKey && !v.ctrlKey : v.ctrlKey && !v.metaKey;
function fireCustomEvent(el, type, init) {
  if (!el)
    return;
  const win = getWindow3(el);
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
function isFocusable(element) {
  if (!element)
    return false;
  return element.matches(focusableSelector) && isVisible(element);
}
var isRef3 = (v) => hasProp4(v, "current");
function addDomEvent3(target, eventName, handler, options) {
  const node = isRef3(target) ? target.current : runIfFn4(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function trackInteractOutside(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside } = options;
  if (!node)
    return;
  const doc = getDocument3(node);
  const win = getWindow3(node);
  function isEventOutside(event) {
    const target = getEventTarget2(event);
    if (!(target instanceof win.HTMLElement)) {
      return false;
    }
    if (!contains3(doc.documentElement, target)) {
      return false;
    }
    if (contains3(node, target)) {
      return false;
    }
    return !(exclude == null ? void 0 : exclude(target));
  }
  let clickHandler;
  function onPointerDown(event) {
    function handler() {
      if (!node || !isEventOutside(event))
        return;
      if (onPointerDownOutside || onInteractOutside) {
        const handler2 = callAll3(onPointerDownOutside, onInteractOutside);
        node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
      }
      fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: isContextMenuEvent2(event),
          focusable: isFocusable(getEventTarget2(event))
        }
      });
    }
    if (event.pointerType === "touch") {
      doc.removeEventListener("click", handler);
      clickHandler = handler;
      doc.addEventListener("click", handler, { once: true });
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(addDomEvent3(doc, "pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    if (!node || !isEventOutside(event))
      return;
    if (onFocusOutside || onInteractOutside) {
      const handler = callAll3(onFocusOutside, onInteractOutside);
      node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
    }
    fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: event,
        contextmenu: false,
        focusable: isFocusable(getEventTarget2(event))
      }
    });
  }
  cleanups.add(addDomEvent3(doc, "focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    if (clickHandler)
      doc.removeEventListener("click", clickHandler);
    cleanups.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/dismissable/dist/chunk-PYR5T5VL.mjs
function warn2(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c2 = a2.length === 2 ? a2[0] : true;
  if (c2 && true) {
    console.warn(m);
  }
}
function trackDismissableElement(node, options) {
  if (!node) {
    warn2("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a, _b;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target))
      return;
    (_a = options.onPointerDownOutside) == null ? void 0 : _a.call(options, event);
    (_b = options.onInteractOutside) == null ? void 0 : _b.call(options, event);
    if (event.defaultPrevented)
      return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a, _b;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target))
      return;
    (_a = options.onFocusOutside) == null ? void 0 : _a.call(options, event);
    (_b = options.onInteractOutside) == null ? void 0 : _b.call(options, event);
    if (event.defaultPrevented)
      return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a;
    if (!layerStack.isTopMost(node))
      return;
    (_a = options.onEscapeKeyDown) == null ? void 0 : _a.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node)
      return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    return _containers.some((node2) => contains2(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups = [
    pointerBlocking ? disablePointerEventsOutside(node) : void 0,
    trackEscapeKeydown(onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/menu/dist/chunk-PP4ZPDWP.mjs
var runIfFn5 = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res != null ? res : void 0;
};
function compact2(obj) {
  if (obj === void 0)
    return obj;
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0).map(([key, value]) => [key, isObject(value) ? compact2(value) : value])
  );
}
var isRef4 = (v) => hasProp(v, "current");
var fallback2 = { pageX: 0, pageY: 0, clientX: 0, clientY: 0 };
function extractInfo(event, type = "page") {
  const point2 = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] || fallback2 : event;
  return {
    point: {
      x: point2[`${type}X`],
      y: point2[`${type}Y`]
    }
  };
}
function addDomEvent4(target, eventName, handler, options) {
  const node = isRef4(target) ? target.current : runIfFn5(target);
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
}
function addPointerEvent(target, event, listener, options) {
  var _a;
  const type = (_a = getEventName(event)) != null ? _a : event;
  return addDomEvent4(target, type, wrapHandler(listener, event === "pointerdown"), options);
}
function wrapHandler(fn, filter = false) {
  const listener = (event) => {
    fn(event, extractInfo(event));
  };
  return filter ? filterPrimaryPointer(listener) : listener;
}
function filterPrimaryPointer(fn) {
  return (event) => {
    var _a;
    const win = (_a = event.view) != null ? _a : window;
    const isMouseEvent = event instanceof win.MouseEvent;
    const isPrimary = !isMouseEvent || isMouseEvent && event.button === 0;
    if (isPrimary)
      fn(event);
  };
}
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getEventName(evt) {
  if (supportsPointerEvent())
    return evt;
  if (supportsTouchEvent())
    return touchEventNames[evt];
  if (supportsMouseEvent())
    return mouseEventNames[evt];
  return evt;
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return function cleanup() {
    globalThis.cancelAnimationFrame(id);
  };
}
var point = (x, y) => ({ x, y });
function createRect(r2) {
  const { x, y, width, height } = r2;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: point(midX, midY)
  };
}
function getRectCorners(v) {
  const top = point(v.minX, v.minY);
  const right = point(v.maxX, v.minY);
  const bottom = point(v.maxX, v.maxY);
  const left = point(v.minX, v.maxY);
  return { top, right, bottom, left };
}
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point2) {
  const { x, y } = point2;
  let c2 = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi = polygon[i2].x;
    const yi = polygon[i2].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c2 = !c2;
    }
  }
  return c2;
}
var { not: not2, and: and2 } = guards;
function machine(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "menu",
      initial: "unknown",
      context: {
        highlightedId: null,
        hoverId: null,
        parent: null,
        children: {},
        intentPolygon: null,
        loop: false,
        suspendPointer: false,
        anchorPoint: null,
        closeOnSelect: true,
        isPlacementComplete: false,
        focusTriggerOnClose: true,
        ...ctx,
        pointerdownNode: null,
        typeahead: findByTypeahead.defaultOptions,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "applyAnchorPoint"
      },
      on: {
        SET_PARENT: {
          actions: "setParentMenu"
        },
        SET_CHILD: {
          actions: "setChildMenu"
        },
        OPEN: {
          target: "open",
          actions: "invokeOnOpen"
        },
        OPEN_AUTOFOCUS: {
          internal: true,
          target: "open",
          actions: ["focusFirstItem", "invokeOnOpen"]
        },
        CLOSE: {
          target: "closed",
          actions: "invokeOnClose"
        },
        RESTORE_FOCUS: {
          actions: "restoreFocus"
        },
        SET_VALUE: {
          actions: ["setOptionValue", "invokeOnValueChange"]
        },
        SET_HIGHLIGHTED_ID: {
          actions: "setFocusedItem"
        }
      },
      states: {
        unknown: {
          on: {
            SETUP: "idle"
          }
        },
        idle: {
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_FOCUS: {
              guard: not2("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          after: {
            LONG_PRESS_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            CONTEXT_MENU_CANCEL: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        opening: {
          after: {
            SUBMENU_OPEN_DELAY: {
              target: "open",
              actions: "invokeOnOpen"
            }
          },
          on: {
            BLUR: {
              target: "closed",
              actions: "invokeOnClose"
            },
            TRIGGER_POINTERLEAVE: {
              target: "closed",
              actions: "invokeOnClose"
            }
          }
        },
        closing: {
          tags: ["visible"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus", "invokeOnClose"]
            }
          },
          on: {
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentFocus"]
            }
          }
        },
        closed: {
          entry: ["clearFocusedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            TRIGGER_CLICK: {
              target: "open",
              actions: "invokeOnOpen"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: {
              target: "open",
              actions: ["focusFirstItem", "invokeOnOpen"]
            },
            ARROW_UP: {
              target: "open",
              actions: ["focusLastItem", "invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["visible"],
          activities: ["trackInteractOutside", "computePlacement"],
          entry: ["focusMenu", "resumePointer"],
          exit: ["clearPointerdownNode"],
          on: {
            TRIGGER_CLICK: {
              guard: not2("isTriggerItem"),
              target: "closed",
              actions: "invokeOnClose"
            },
            TAB: [
              {
                guard: "isForwardTabNavigation",
                actions: ["focusNextItem"]
              },
              { actions: ["focusPrevItem"] }
            ],
            ARROW_UP: {
              actions: ["focusPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["focusNextItem", "focusMenu"]
            },
            ARROW_LEFT: {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            },
            HOME: {
              actions: ["focusFirstItem", "focusMenu"]
            },
            END: {
              actions: ["focusLastItem", "focusMenu"]
            },
            REQUEST_CLOSE: {
              target: "closed",
              actions: "invokeOnClose"
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemFocused",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemFocused",
                actions: "openSubmenu"
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickFocusedItem"
              },
              {
                actions: "clickFocusedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: and2(not2("suspendPointer"), not2("isTargetFocused")),
                actions: ["focusItem", "focusMenu"]
              },
              {
                guard: not2("isTargetFocused"),
                actions: "setHoveredItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and2(not2("suspendPointer"), not2("isTriggerItem")),
              actions: "clearFocusedItem"
            },
            ITEM_CLICK: [
              {
                guard: and2(not2("isTriggerItemFocused"), not2("isFocusedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: [
                  "invokeOnSelect",
                  "changeOptionValue",
                  "invokeOnValueChange",
                  "closeRootMenu",
                  "invokeOnClose"
                ]
              },
              {
                guard: and2(not2("isTriggerItemFocused"), not2("isFocusedItemEditable")),
                actions: ["invokeOnSelect", "changeOptionValue", "invokeOnValueChange"]
              },
              { actions: ["focusItem"] }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: ["setPointerdownNode", "focusItem"]
            },
            TYPEAHEAD: {
              actions: "focusMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => {
          var _a, _b;
          return !!((_b = (_a = evt.option) == null ? void 0 : _a.closeOnSelect) != null ? _b : ctx2.closeOnSelect);
        },
        isMenuFocused: (ctx2) => {
          const menu = dom.getContentEl(ctx2);
          const activeElement = dom.getActiveElement(ctx2);
          return contains(menu, activeElement);
        },
        isTargetFocused: (ctx2, evt) => ctx2.highlightedId === evt.target.id,
        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),
        isTriggerItemFocused: (ctx2, evt) => {
          var _a;
          const target = (_a = evt.target) != null ? _a : dom.getFocusedItem(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isForwardTabNavigation: (_ctx, evt) => !evt.shiftKey,
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isFocusedItemEditable: (ctx2) => isElementEditable(dom.getFocusedItem(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        }
      },
      activities: {
        computePlacement(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(dom.getTriggerEl(ctx2), dom.getPositionerEl(ctx2), {
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
              ctx2.isPlacementComplete = true;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackDismissableElement(dom.getContentEl(ctx2), {
            exclude: [dom.getTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              ctx2.focusTriggerOnClose = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "REQUEST_CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom.getDoc(ctx2);
          return addPointerEvent(doc, "pointermove", (e2) => {
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point: getEventPoint(e2) });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        applyAnchorPoint(ctx2) {
          const point2 = ctx2.anchorPoint;
          if (!point2)
            return;
          const el = dom.getPositionerEl(ctx2);
          if (!el)
            return;
          raf(() => {
            Object.assign(el.style, {
              position: "absolute",
              top: "0",
              left: "0",
              transform: `translate3d(${point2.x}px, ${point2.y}px, 0)`
            });
            ctx2.isPlacementComplete = true;
          });
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        invokeOnValueChange(ctx2, evt) {
          var _a, _b, _c;
          if (!ctx2.value)
            return;
          const name = (_b = evt.name) != null ? _b : (_a = evt.option) == null ? void 0 : _a.name;
          if (!name)
            return;
          const values = ctx2.value[name];
          const valueAsArray = isArray(values) ? Array.from(values) : values;
          (_c = ctx2.onValueChange) == null ? void 0 : _c.call(ctx2, { name, value: valueAsArray });
        },
        setOptionValue(ctx2, evt) {
          if (!ctx2.value)
            return;
          ctx2.value[evt.name] = evt.value;
        },
        changeOptionValue(ctx2, evt) {
          if (!evt.option || !ctx2.value)
            return;
          const { value, type, name } = evt.option;
          const values = ctx2.value[name];
          if (type === "checkbox" && isArray(values)) {
            ctx2.value[name] = values.includes(value) ? remove(values, value) : add(values, value);
          } else {
            ctx2.value[name] = value;
          }
        },
        clickFocusedItem(ctx2) {
          var _a;
          (_a = dom.getFocusedItem(ctx2)) == null ? void 0 : _a.click();
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon)
            return;
          const rightSide = getBasePlacement(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setFocusedItem(ctx2, evt) {
          ctx2.highlightedId = evt.id;
        },
        clearFocusedItem(ctx2) {
          ctx2.highlightedId = null;
        },
        focusMenu(ctx2) {
          raf(() => {
            const activeEl = dom.getActiveElement(ctx2);
            const contentEl = dom.getContentEl(ctx2);
            if (contains(contentEl, activeEl))
              return;
            contentEl == null ? void 0 : contentEl.focus();
          });
        },
        focusFirstItem(ctx2) {
          const first2 = dom.getFirstEl(ctx2);
          if (!first2)
            return;
          ctx2.highlightedId = first2.id;
        },
        focusLastItem(ctx2) {
          const last2 = dom.getLastEl(ctx2);
          if (!last2)
            return;
          ctx2.highlightedId = last2.id;
        },
        focusNextItem(ctx2, evt) {
          var _a;
          const next = dom.getNextEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = next == null ? void 0 : next.id) != null ? _a : null;
        },
        focusPrevItem(ctx2, evt) {
          var _a;
          const prev = dom.getPrevEl(ctx2, evt.loop);
          ctx2.highlightedId = (_a = prev == null ? void 0 : prev.id) != null ? _a : null;
        },
        invokeOnSelect(ctx2) {
          var _a;
          if (!ctx2.highlightedId)
            return;
          (_a = ctx2.onSelect) == null ? void 0 : _a.call(ctx2, { value: ctx2.highlightedId });
          if (!ctx2.closeOnSelect) {
            ctx2.pointerdownNode = null;
          }
        },
        focusItem(ctx2, event) {
          ctx2.highlightedId = event.id;
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.focusTriggerOnClose)
            return;
          raf(() => {
            var _a;
            return (_a = dom.getTriggerEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        focusMatchedItem(ctx2, evt) {
          const node = dom.getElemByKey(ctx2, evt.key);
          if (node)
            ctx2.highlightedId = node.id;
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom.getFocusedItem(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("FOCUS_MENU");
        },
        setHoveredItem(ctx2, evt) {
          ctx2.hoverId = evt.id;
        },
        restoreFocus(ctx2) {
          if (!ctx2.hoverId)
            return;
          ctx2.highlightedId = ctx2.hoverId;
          ctx2.hoverId = null;
        },
        restoreParentFocus(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("RESTORE_FOCUS");
        },
        setPointerdownNode(ctx2, evt) {
          ctx2.pointerdownNode = ref(evt.target);
        },
        clearPointerdownNode(ctx2) {
          ctx2.pointerdownNode = null;
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpen) == null ? void 0 : _a.call(ctx2);
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onClose) == null ? void 0 : _a.call(ctx2);
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}

// node_modules/@zag-js/types/dist/chunk-D5R2W3NO.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}

// node_modules/@zag-js/react/dist/chunk-BEOSRPKO.mjs
var normalizeProps = createNormalizer((v) => v);

// node_modules/@zag-js/react/dist/chunk-ETPJCCVP.mjs
var import_react3 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@zag-js/react/dist/chunk-DARLHIWS.mjs
var import_react4 = __toESM(require_react(), 1);
var __DEV__2 = true;
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    pathList.current = w(state, affected);
  });
  (0, import_react4.useDebugValue)(pathList.current);
};
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = (0, import_react4.useRef)();
  const lastAffected = (0, import_react4.useRef)();
  let inRender = true;
  const currSnapshot = (0, import_react4.useSyncExternalStore)(
    (0, import_react4.useCallback)(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject);
      try {
        if (!inRender && lastSnapshot.current && lastAffected.current && !p(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch (e2) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject)
  );
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react4.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if (__DEV__2) {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache2 = (0, import_react4.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return u(currSnapshot, currAffected, proxyCache2);
}

// node_modules/@zag-js/react/dist/chunk-5KD5OGA2.mjs
var import_react5 = __toESM(require_react(), 1);
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react5.useLayoutEffect : import_react5.useEffect;
function useConstant(fn) {
  const ref2 = (0, import_react5.useRef)();
  if (!ref2.current)
    ref2.current = { v: fn() };
  return ref2.current.v;
}
function useService(machine2, options) {
  const { actions, state: hydratedState, context } = options != null ? options : {};
  const service = useConstant(() => {
    const _machine = typeof machine2 === "function" ? machine2() : machine2;
    return context ? _machine.withContext(context) : _machine;
  });
  useSafeLayoutEffect(() => {
    service.start(hydratedState);
    if (service.state.can("SETUP")) {
      service.send("SETUP");
    }
    return () => {
      service.stop();
    };
  }, []);
  service.setOptions({ actions });
  service.setContext(context);
  return service;
}
function useMachine(machine2, options) {
  const service = useService(machine2, options);
  const state = useSnapshot(service.state);
  const typedState = state;
  return [typedState, service.send, service];
}

// node_modules/@thirdweb-dev/react/dist/index-aed60ee9.esm.js
var ThirdwebAuthConfigContext = (0, import_react6.createContext)(void 0);
var ThirdwebAuthConfigProvider = (_ref) => {
  let {
    value,
    children
  } = _ref;
  const authConfig = (0, import_react6.useMemo)(() => value ? {
    ...value,
    authUrl: value.authUrl.replace(/\/$/, "")
  } : void 0, [value]);
  return (0, import_jsx_runtime2.jsx)(ThirdwebAuthConfigContext.Provider, {
    value: authConfig,
    children
  });
};
function useThirdwebAuthConfig() {
  return (0, import_react6.useContext)(ThirdwebAuthConfigContext);
}
var __DEV__3 = true;
var chain2 = {
  mainnet: {
    id: ChainId.Mainnet,
    name: "Ethereum Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mainnet],
    rpcUrls: ["https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://etherscan.io"
    }]
  },
  goerli: {
    id: ChainId.Goerli,
    name: "Goerli",
    nativeCurrency: NATIVE_TOKENS[ChainId.Goerli],
    rpcUrls: ["https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }],
    testnet: true
  },
  polygonMainnet: {
    id: ChainId.Polygon,
    name: "Polygon Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Polygon],
    rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://polygonscan.com"
    }]
  },
  polygonTestnetMumbai: {
    id: ChainId.Mumbai,
    name: "Mumbai",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mumbai],
    rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }],
    testnet: true
  },
  avalanche: {
    id: ChainId.Avalanche,
    name: "Avalanche",
    nativeCurrency: NATIVE_TOKENS[ChainId.Avalanche],
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc", "https://rpc.ankr.com/avalanche"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://snowtrace.io/"
    }],
    testnet: false
  },
  avalancheFujiTestnet: {
    id: ChainId.AvalancheFujiTestnet,
    name: "Avalanche Fuji Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.AvalancheFujiTestnet],
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io/"
    }],
    testnet: true
  },
  fantom: {
    id: ChainId.Fantom,
    name: "Fantom Opera",
    nativeCurrency: NATIVE_TOKENS[ChainId.Fantom],
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://ftmscan.com/"
    }],
    testnet: false
  },
  fantomTestnet: {
    id: ChainId.FantomTestnet,
    name: "Fantom Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.FantomTestnet],
    rpcUrls: ["https://rpc.testnet.fantom.network"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://testnet.ftmscan.com/"
    }],
    testnet: true
  },
  optimism: {
    id: ChainId.Optimism,
    name: "Optimism",
    nativeCurrency: NATIVE_TOKENS[ChainId.Optimism],
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://optimistic.etherscan.io/"
    }],
    testnet: false
  },
  optimismGoerli: {
    id: ChainId.OptimismGoerli,
    name: "Optimism Goerli Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.OptimismGoerli],
    rpcUrls: ["https://goerli.optimism.io/"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io/"
    }],
    testnet: true
  },
  arbitrum: {
    id: ChainId.Arbitrum,
    name: "Arbitrum One",
    nativeCurrency: NATIVE_TOKENS[ChainId.Arbitrum],
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://arbiscan.io/"
    }],
    testnet: false
  },
  arbitrumGoerli: {
    id: ChainId.ArbitrumGoerli,
    name: "Arbitrum Goerli",
    nativeCurrency: NATIVE_TOKENS[ChainId.ArbitrumGoerli],
    rpcUrls: ["https://goerli-rollup.arbitrum.io/rpc/"],
    blockExplorers: [{
      name: "Arbitrum Goerli Rollup Explorer",
      url: "https://goerli-rollup-explorer.arbitrum.io"
    }],
    testnet: true
  },
  binanceSmartChainMainnet: {
    id: ChainId.BinanceSmartChainMainnet,
    name: "Binance Smart Chain Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.BinanceSmartChainMainnet],
    rpcUrls: ["https://bsc-dataseed1.binance.org"],
    blockExplorers: [{
      name: "BscScan",
      url: "https://bscscan.com/"
    }],
    testnet: false
  },
  binanceSmartChainTestnet: {
    id: ChainId.BinanceSmartChainTestnet,
    name: "Binance Smart Chain Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.BinanceSmartChainTestnet],
    rpcUrls: ["https://data-seed-prebsc-1-s1.binance.org:8545"],
    blockExplorers: [{
      name: "BscScan",
      url: "https://testnet.bscscan.com/"
    }],
    testnet: true
  }
};
var defaultSupportedChains = Object.values(chain2);
function getChainFromChainId(chainId) {
  return defaultSupportedChains.find((c2) => c2.id === chainId);
}
var ThirdwebConfigContext = (0, import_react6.createContext)({
  rpcUrlMap: DEFAULT_RPC_URLS,
  supportedChains: defaultSupportedChains
});
var ThirdwebConfigProvider = (_ref) => {
  let {
    value,
    children
  } = _ref;
  return (0, import_jsx_runtime2.jsx)(ThirdwebConfigContext.Provider, {
    value,
    children
  });
};
function useThirdwebConfigContext() {
  return (0, import_react6.useContext)(ThirdwebConfigContext);
}
var INITIAL_CONTEXT_VALUE = {
  wallet: void 0,
  address: void 0,
  chainId: void 0,
  signer: void 0
};
var ThirdwebConnectedWalletContext = (0, import_react6.createContext)(INITIAL_CONTEXT_VALUE);
var ThirdwebConnectedWalletProvider = (_ref) => {
  let {
    signer,
    children
  } = _ref;
  const {
    rpcUrlMap
  } = useThirdwebConfigContext();
  const [contextValue, setContextValue] = (0, import_react6.useState)({
    ...INITIAL_CONTEXT_VALUE,
    signer: signer ? signer : void 0
  });
  (0, import_react6.useEffect)(() => {
    setContextValue((val) => ({
      ...val,
      signer: signer ? signer : void 0
    }));
  }, [signer]);
  (0, import_react6.useEffect)(() => {
    let s2 = signer;
    if (signer) {
      Promise.all([signer.getAddress(), signer.getChainId()]).then((_ref2) => {
        let [address, chainId] = _ref2;
        const rpcUrl = rpcUrlMap[chainId];
        if (signer === s2) {
          const wallet = new UserWallet(signer, {
            readonlySettings: rpcUrl ? {
              rpcUrl,
              chainId
            } : void 0
          });
          setContextValue({
            wallet,
            address,
            chainId,
            signer
          });
        }
      }).catch((err) => {
        if (__DEV__3) {
          console.warn("failed to get wallet instance in `<ThirdwebConnectedWalletProvider />`", err);
        }
      });
    } else {
      setContextValue(INITIAL_CONTEXT_VALUE);
    }
    return () => {
      s2 = void 0;
    };
  }, [signer]);
  return (0, import_jsx_runtime2.jsx)(ThirdwebConnectedWalletContext.Provider, {
    value: contextValue,
    children
  });
};
function useThirdwebConnectedWalletContext() {
  return (0, import_react6.useContext)(ThirdwebConnectedWalletContext);
}
var ThirdwebSDKContext = (0, import_react6.createContext)({
  desiredChainId: -1
});
var WrappedThirdwebSDKProvider = (_ref) => {
  let {
    sdkOptions,
    desiredChainId,
    storageInterface,
    provider,
    queryClient,
    authConfig,
    children
  } = _ref;
  const {
    signer
  } = useThirdwebConnectedWalletContext();
  const [sdk, setSDK] = (0, import_react6.useState)();
  (0, import_react6.useEffect)(() => {
    if (!desiredChainId || typeof window === "undefined") {
      return void 0;
    }
    const _sdk = new ThirdwebSDK(provider, sdkOptions, storageInterface);
    if (signer) {
      _sdk.updateSignerOrProvider(signer);
    }
    _sdk._constructedAt = Date.now();
    _sdk._chainId = desiredChainId;
    setSDK(_sdk);
  }, [provider, sdkOptions, storageInterface, desiredChainId]);
  (0, import_react6.useEffect)(() => {
    if (sdk && sdk._chainId === desiredChainId) {
      if (signer) {
        sdk.updateSignerOrProvider(signer);
      } else {
        sdk.updateSignerOrProvider(provider);
      }
    }
  }, [signer, sdk, desiredChainId, provider]);
  const ctxValue = (0, import_react6.useMemo)(() => ({
    sdk,
    desiredChainId: desiredChainId || -1,
    _inProvider: true
  }), [desiredChainId, sdk]);
  return (0, import_jsx_runtime2.jsx)(QueryClientProviderWithDefault, {
    queryClient,
    children: (0, import_jsx_runtime2.jsx)(ThirdwebAuthConfigProvider, {
      value: authConfig,
      children: (0, import_jsx_runtime2.jsx)(ThirdwebSDKContext.Provider, {
        value: ctxValue,
        children
      })
    })
  });
};
var ThirdwebSDKProvider = (_ref2) => {
  let {
    signer,
    children,
    ...restProps
  } = _ref2;
  return (0, import_jsx_runtime2.jsx)(ThirdwebConnectedWalletProvider, {
    signer,
    children: (0, import_jsx_runtime2.jsx)(WrappedThirdwebSDKProvider, {
      ...restProps,
      children
    })
  });
};
function useSDKContext() {
  const ctx = (0, import_react6.useContext)(ThirdwebSDKContext);
  invariant(ctx._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?");
  return ctx;
}
function useSDK() {
  const {
    sdk
  } = useSDKContext();
  return sdk;
}
function useDesiredChainId() {
  const {
    desiredChainId
  } = useSDKContext();
  return desiredChainId;
}
function useSDKChainId() {
  const sdk = useSDK();
  return sdk == null ? void 0 : sdk._chainId;
}
var defaultdAppMeta = {
  name: "thirdweb powered dApp"
};
var defaultWalletConnectors = ["metamask", "walletConnect", "walletLink"];
var ThirdwebProvider = (_ref) => {
  let {
    sdkOptions,
    chainRpc = DEFAULT_RPC_URLS,
    supportedChains = defaultSupportedChains.map((c2) => c2.id),
    walletConnectors = defaultWalletConnectors,
    dAppMeta = defaultdAppMeta,
    desiredChainId,
    authConfig,
    storageInterface,
    queryClient,
    autoConnect = true,
    children
  } = _ref;
  const _supporrtedChains = (0, import_react6.useMemo)(() => {
    return supportedChains.map((c2) => {
      if (typeof c2 === "number") {
        return defaultSupportedChains.find((sc) => sc.id === c2);
      }
      return c2;
    }).filter((c2) => c2 !== void 0);
  }, [supportedChains]);
  const _rpcUrlMap = (0, import_react6.useMemo)(() => {
    return _supporrtedChains.reduce((prev, curr) => {
      prev[curr.id] = curr.id in chainRpc ? getProviderForNetwork(chainRpc[curr.id] || curr.rpcUrls[0]) : curr.rpcUrls[0];
      return prev;
    }, {});
  }, [chainRpc, _supporrtedChains]);
  const wagmiProps = (0, import_react6.useMemo)(() => {
    const walletConnectClientMeta = {
      name: dAppMeta.name,
      url: dAppMeta.url || "",
      icons: [dAppMeta.logoUrl || ""],
      description: dAppMeta.description || ""
    };
    const walletLinkClientMeta = {
      appName: dAppMeta.name,
      appLogoUrl: dAppMeta.logoUrl,
      darkMode: dAppMeta.isDarkMode
    };
    return {
      autoConnect,
      connectorStorageKey: "tw:provider:connectors",
      connectors: (_ref2) => {
        let {
          chainId
        } = _ref2;
        return walletConnectors.map((connector) => {
          if (connector instanceof Connector) {
            return connector;
          }
          if (typeof connector === "string" && (connector === "injected" || connector === "metamask") || typeof connector === "object" && (connector.name === "injected" || connector.name === "metamask")) {
            return new InjectedConnector({
              options: typeof connector === "string" ? {
                shimDisconnect: true,
                shimChainChangedDisconnect: true
              } : connector.options,
              chains: _supporrtedChains
            });
          }
          if (typeof connector === "string" && connector === "walletConnect" || typeof connector === "object" && connector.name === "walletConnect") {
            return new WalletConnectConnector({
              options: typeof connector === "string" ? {
                chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true
              } : {
                chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true,
                ...connector.options
              },
              chains: _supporrtedChains
            });
          }
          if (typeof connector === "string" && (connector === "coinbase" || connector === "walletLink") || typeof connector === "object" && (connector.name === "coinbase" || connector.name === "walletLink")) {
            const jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];
            return new CoinbaseWalletConnector({
              chains: _supporrtedChains,
              options: typeof connector === "string" ? {
                ...walletLinkClientMeta,
                jsonRpcUrl
              } : {
                ...walletLinkClientMeta,
                jsonRpcUrl,
                ...connector.options
              }
            });
          }
          return null;
        }).filter((c2) => c2 !== null);
      }
    };
  }, [dAppMeta.name, dAppMeta.url, dAppMeta.logoUrl, dAppMeta.description, dAppMeta.isDarkMode, autoConnect, walletConnectors, _supporrtedChains, _rpcUrlMap, desiredChainId]);
  const readonlySettings = (0, import_react6.useMemo)(() => {
    var _a, _b;
    if (((_a = sdkOptions == null ? void 0 : sdkOptions.readonlySettings) == null ? void 0 : _a.rpcUrl) && ((_b = sdkOptions == null ? void 0 : sdkOptions.readonlySettings) == null ? void 0 : _b.chainId)) {
      return sdkOptions.readonlySettings;
    }
    if (!desiredChainId) {
      return void 0;
    }
    let rpcUrl = _rpcUrlMap[desiredChainId];
    try {
      rpcUrl = getProviderForNetwork(rpcUrl);
    } catch (e2) {
      console.error(`failed to configure rpc url for chain: "${desiredChainId}". Did you forget to pass "desiredChainId" to the <ThirdwebProvider /> component?`);
      return void 0;
    }
    return {
      chainId: desiredChainId,
      rpcUrl
    };
  }, [_rpcUrlMap, desiredChainId, sdkOptions == null ? void 0 : sdkOptions.readonlySettings]);
  const sdkOptionsWithDefaults = (0, import_react6.useMemo)(() => {
    const opts = sdkOptions;
    return {
      ...opts,
      readonlySettings
    };
  }, [sdkOptions, readonlySettings]);
  return (0, import_jsx_runtime2.jsx)(ThirdwebConfigProvider, {
    value: {
      rpcUrlMap: _rpcUrlMap,
      supportedChains: _supporrtedChains
    },
    children: (0, import_jsx_runtime2.jsx)(Provider, {
      ...wagmiProps,
      children: (0, import_jsx_runtime2.jsx)(ThirdwebSDKProviderWagmiWrapper, {
        queryClient,
        desiredChainId,
        sdkOptions: sdkOptionsWithDefaults,
        storageInterface,
        authConfig,
        children
      })
    })
  });
};
var ThirdwebSDKProviderWagmiWrapper = (_ref3) => {
  let {
    children,
    ...props
  } = _ref3;
  const provider = useProvider();
  const [signer] = useSigner();
  return (0, import_jsx_runtime2.jsx)(ThirdwebSDKProvider, {
    signer: signer.data,
    provider,
    ...props,
    children
  });
};
var warnSet = /* @__PURE__ */ new Set();
var showDeprecationWarning = (deprecated, replacement) => {
  if (__DEV__3) {
    if (warnSet.has(`${deprecated}:${replacement}`)) {
      return;
    }
    warnSet.add(`${deprecated}:${replacement}`);
    console.warn(`\`${deprecated}\` is deprecated and will be removed in a future major version. Please use \`${replacement}\` instead.`);
  }
};
var TW_CACHE_KEY_PREFIX = "tw-cache";
function enforceCachePrefix(input) {
  return [TW_CACHE_KEY_PREFIX, ...input.filter((i2) => typeof i2 !== "string" || i2 !== TW_CACHE_KEY_PREFIX)];
}
function createContractCacheKey() {
  let contractAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : lib_exports7.AddressZero;
  let input = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return enforceCachePrefix(["contract", contractAddress, ...input]);
}
function createCacheKeyWithNetwork(input, chainId) {
  return enforceCachePrefix(cacheKeys.network.active(chainId).concat(input));
}
function invalidateContractAndBalances(queryClient, contractAddress, chainId) {
  return Promise.all([queryClient.invalidateQueries(enforceCachePrefix(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), chainId))), queryClient.invalidateQueries(enforceCachePrefix(createCacheKeyWithNetwork(["balance"], chainId)))]);
}
var cacheKeys = {
  auth: {
    user: () => enforceCachePrefix(["user"])
  },
  network: {
    active: (chainId) => enforceCachePrefix(["chainId", chainId])
  },
  wallet: {
    balance: (chainId, walletAddress, tokenAddress) => enforceCachePrefix(createCacheKeyWithNetwork(enforceCachePrefix(["balance", {
      walletAddress,
      tokenAddress
    }]), chainId))
  },
  contract: {
    read: (contractAddress, fnIdentity) => createContractCacheKey(contractAddress, ["read", fnIdentity]),
    type: (contractAddress) => createContractCacheKey(contractAddress, ["contract-type"]),
    compilerMetadata: (contractAddress) => createContractCacheKey(contractAddress, ["publish-metadata"]),
    typeAndCompilerMetadata: (contractAddress) => createContractCacheKey(contractAddress, ["contract-type-and-metadata"]),
    metadata: (contractAddress) => createContractCacheKey(contractAddress, ["metadata"]),
    extractFunctions: (contractAddress) => createContractCacheKey(contractAddress, ["extractFunctions"]),
    call: (contractAddress, functionName, args) => createContractCacheKey(contractAddress, ["call", functionName, args]),
    events: {
      getEvents: (contractAddress, eventName) => createContractCacheKey(contractAddress, ["events", "getEvents", {
        eventName
      }]),
      getAllEvents: (contractAddress) => createContractCacheKey(contractAddress, ["events", "getAllEvents"])
    },
    // specific contract types
    nft: {
      get: (contractAddress, tokenId) => createContractCacheKey(contractAddress, ["get", {
        tokenId
      }]),
      balanceOf: (contractAddress, owner, tokenId) => createContractCacheKey(contractAddress, ["balanceOf", {
        owner,
        tokenId
      }]),
      query: {
        all: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["query", "all", params] : ["query", "all"]),
        totalCirculatingSupply: (contractAddress) => createContractCacheKey(contractAddress, ["query", "totalCirculatingSupply"]),
        totalCount: (contractAddress) => createContractCacheKey(contractAddress, ["query", "totalCount"]),
        owned: {
          all: (contractAddress, owner) => createContractCacheKey(contractAddress, ["query", "owned", "all", owner])
        }
      },
      drop: {
        getAllUnclaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllUnclaimed", params] : ["getAllUnclaimed"]),
        totalUnclaimedSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalUnclaimedSupply"]),
        totalClaimedSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalClaimedSupply"]),
        revealer: {
          getBatchesToReveal: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getBatchesToReveal", params] : ["getBatchesToReveal"])
        }
      }
    },
    token: {
      totalSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalSupply"]),
      decimals: (contractAddress) => createContractCacheKey(contractAddress, ["decimals"]),
      balanceOf: (contractAddress, walletAddress) => createContractCacheKey(contractAddress, ["balanceOf", {
        walletAddress
      }])
    },
    marketplace: {
      getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["getListing", {
        listingId
      }]),
      getAllListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllListings", params] : ["getAllListings"]),
      getTotalCount: (contractAddress) => createContractCacheKey(contractAddress, ["getTotalCount"]),
      getActiveListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getActiveListings", params] : ["getActiveListings"]),
      getBidBufferBps: (contractAddress) => createContractCacheKey(contractAddress, ["getBidBufferBps"]),
      auction: {
        getWinningBid: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinningBid", {
          listingId
        }]),
        getWinner: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinner", {
          listingId
        }])
      }
    }
  },
  // extensions
  extensions: {
    claimConditions: {
      getActive: (contractAddress, tokenId, options) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getActive", {
        tokenId
      }, options] : ["claimConditions", "getActive", options]),
      getAll: (contractAddress, tokenId, options) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getAll", {
        tokenId
      }, options] : ["claimConditions", "getAll", options]),
      getClaimerProofs: (contractAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getClaimerProofs", {
        tokenId
      }] : ["claimConditions", "getClaimerProofs"]),
      getClaimIneligibilityReasons: (contractAddress, params, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getIneligibilityReasons", {
        tokenId
      }, params] : ["claimConditions", "getIneligibilityReasons", params]),
      // combinations of queries cache keys
      useActiveClaimConditionForWallet: (contractAddress, walletAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "useActiveClaimConditionForWallet", {
        tokenId,
        walletAddress
      }, ,] : ["claimConditions", "getIneligibilityReasons", {
        walletAddress
      }])
    },
    // primary sale contracts
    sales: {
      getRecipient: (contractAddress) => createContractCacheKey(contractAddress, ["sales"])
    },
    // royalties
    royalties: {
      getDefaultRoyaltyInfo: (contractAddress) => createContractCacheKey(contractAddress, ["royalties"])
    },
    // platform fees
    platformFees: {
      get: (contractAddress) => createContractCacheKey(contractAddress, ["platformFees"])
    },
    // contract metadata
    metadata: {
      get: (contractAddress) => createContractCacheKey(contractAddress, ["metadata"])
    },
    roles: {
      getAll: (contractAddress) => createContractCacheKey(contractAddress, ["roles"]),
      get: (contractAddress, role) => createContractCacheKey(contractAddress, ["roles", {
        role
      }])
    }
  }
};
function useQueryWithNetwork(queryKey, queryFn, options) {
  const activeChainId = useSDKChainId();
  const mergedOptions = {
    ...options,
    enabled: !!(activeChainId && (options == null ? void 0 : options.enabled))
  };
  return useQuery(createCacheKeyWithNetwork(queryKey, activeChainId), queryFn, mergedOptions);
}
function useBalance(tokenAddress) {
  const walletAddress = useAddress();
  const {
    wallet,
    address,
    chainId
  } = useThirdwebConnectedWalletContext();
  const cacheKey = (0, import_react6.useMemo)(() => {
    return cacheKeys.wallet.balance(chainId || -1, address, tokenAddress);
  }, [chainId, tokenAddress, address]);
  return useQuery(cacheKey, () => {
    return wallet == null ? void 0 : wallet.balance(tokenAddress);
  }, {
    // if user is not logged in no reason to try to fetch
    enabled: !!wallet && !!walletAddress && !!chainId,
    retry: true,
    keepPreviousData: false
  });
}
function useConnectedWallet() {
  return useThirdwebConnectedWalletContext().wallet;
}
function useAddress() {
  return useThirdwebConnectedWalletContext().address;
}
function useChainId() {
  return useThirdwebConnectedWalletContext().chainId;
}
async function fetchContractType(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return await sdk.resolveContractType(contractAddress);
  } catch (err) {
    console.error("failed to resolve contract type", err);
    return "custom";
  }
}
function useContractType(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(
    cacheKeys.contract.type(contractAddress),
    () => fetchContractType(contractAddress, sdk),
    // is immutable, so infinite stale time
    {
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk
    }
  );
}
var contractType = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.type(contractAddress), chainId),
  useQuery: useContractType,
  fetchQuery: fetchContractType
};
function fetchCompilerMetadata(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return sdk.getPublisher().fetchCompilerMetadataFromAddress(contractAddress);
  } catch (err) {
    return null;
  }
}
function useCompilerMetadata(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(
    cacheKeys.contract.compilerMetadata(contractAddress),
    () => fetchCompilerMetadata(contractAddress, sdk),
    // is immutable, so infinite stale time
    {
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk
    }
  );
}
var compilerMetadata = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), chainId),
  useQuery: useCompilerMetadata,
  fetchQuery: fetchCompilerMetadata
};
function useContract(contractAddress, contractTypeOrABI) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const activeChainId = useSDKChainId();
  const wallet = useAddress();
  const walletChainId = useChainId();
  const sdkTimestamp = sdk == null ? void 0 : sdk._constructedAt;
  const contractQuery = useQueryWithNetwork(
    // need to add the wallet and walletChainId into the query key so this gets refreshed when the wallet / chain changes!
    neverPersist(["contract-instance", contractAddress, {
      wallet,
      walletChainId,
      sdkTimestamp
    }]),
    async () => {
      var _a;
      requiredParamInvariant(contractAddress, "contract address is required");
      invariant(sdk, "SDK not initialized");
      invariant(activeChainId, "active chain id is required");
      if (!contractTypeOrABI || contractTypeOrABI === "custom") {
        const resolvedContractType = await queryClient.fetchQuery(contractType.cacheKey(contractAddress, activeChainId), () => contractType.fetchQuery(contractAddress, sdk), {
          cacheTime: Infinity,
          staleTime: Infinity
        });
        let abi;
        if (resolvedContractType === "custom") {
          abi = (_a = await queryClient.fetchQuery(compilerMetadata.cacheKey(contractAddress, activeChainId), () => compilerMetadata.fetchQuery(contractAddress, sdk), {
            cacheTime: Infinity,
            staleTime: Infinity,
            retry: 0
          })) == null ? void 0 : _a.abi;
        }
        invariant(resolvedContractType, "failed to resolve contract type");
        return sdk.getContract(contractAddress, abi || resolvedContractType);
      }
      return sdk.getContract(contractAddress, contractTypeOrABI);
    },
    {
      // keep the previous value around while we fetch the new one
      // this is important because otherwise it can lead to flickering (because we need to re-fetch the contract when sdk things change)
      keepPreviousData: true,
      // is immutable, so infinite cache & stale time (for a given key)
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk && !!activeChainId,
      // never retry
      retry: 0
    }
  );
  return {
    ...contractQuery,
    data: contractQuery.data,
    contract: contractQuery.data
  };
}
function useContractMetadata(contract) {
  return useQueryWithNetwork(cacheKeys.contract.metadata(contract == null ? void 0 : contract.getAddress()), async () => {
    requiredParamInvariant(contract, "contract is required");
    return await contract.metadata.get();
  }, {
    enabled: !!contract
  });
}
function useContractMetadataUpdate(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (metadata) => {
    requiredParamInvariant(contract, "contract must be defined");
    return contract.metadata.update(metadata);
  }, {
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId))
  });
}
function useContractEvents(contract, eventName) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    subscribe: true
  };
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const activeChainId = useSDKChainId();
  const cacheKey = (0, import_react6.useMemo)(() => createCacheKeyWithNetwork(eventName ? cacheKeys.contract.events.getAllEvents(contractAddress) : cacheKeys.contract.events.getEvents(contractAddress, eventName), activeChainId), [activeChainId, contractAddress, eventName]);
  (0, import_react6.useEffect)(() => {
    if (!options.subscribe || !contract || !contract) {
      return;
    }
    const cleanupListener = contract.events.listenToAllEvents((contractEvent) => {
      if (eventName && eventName !== contractEvent.eventName) {
        return;
      }
      queryClient.setQueryData(cacheKey, (oldData) => {
        if (!oldData) {
          return [contractEvent];
        }
        const eventIsNotAlreadyInEventsList = oldData.findIndex((e2) => e2.transaction.transactionHash === contractEvent.transaction.transactionHash && e2.transaction.logIndex === contractEvent.transaction.logIndex) === -1;
        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent, ...oldData];
        }
        return oldData;
      });
    });
    return cleanupListener;
  }, [options.subscribe, cacheKey, contract, queryClient, eventName]);
  return useQuery(cacheKey, () => {
    requiredParamInvariant(contract, "contract must be defined");
    if (eventName) {
      return contract.events.getEvents(eventName, options.queryFilter);
    }
    return contract.events.getAllEvents(options.queryFilter);
  }, {
    enabled: !!contract,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}
function useContractRead(contract, functionName) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.call(contractAddress, functionName, args), () => {
    requiredParamInvariant(contract, "contract must be defined");
    requiredParamInvariant(functionName, "function name must be provided");
    return contract.call(functionName, ...args);
  }, {
    enabled: !!contract && !!functionName
  });
}
function useContractWrite(contract, functionName) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (callParams) => {
    requiredParamInvariant(contract, "contract must be defined");
    requiredParamInvariant(functionName, "function name must be provided");
    if (!(callParams == null ? void 0 : callParams.length)) {
      return contract.call(functionName);
    }
    return contract.call(functionName, ...callParams);
  }, {
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId))
  });
}
function useEditionDrop(contractAddress) {
  showDeprecationWarning(`useEditionDrop("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "edition-drop")`);
  return useContract(contractAddress, "edition-drop").contract;
}
function useEdition(contractAddress) {
  showDeprecationWarning(`useEdition("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "edition")`);
  return useContract(contractAddress, "edition").contract;
}
function useNFTDrop(contractAddress) {
  showDeprecationWarning(`useNFTDrop("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "nft-drop")`);
  return useContract(contractAddress, "nft-drop").contract;
}
function useMarketplace(contractAddress) {
  showDeprecationWarning(`useMarketplace("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "marketplace")`);
  return useContract(contractAddress, "marketplace").contract;
}
function useNFTCollection(contractAddress) {
  showDeprecationWarning(`useNFTCollection("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "nft-collection")`);
  return useContract(contractAddress, "nft-collection").contract;
}
function usePack(contractAddress) {
  showDeprecationWarning(`usePack("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "pack")`);
  return useContract(contractAddress, "pack").contract;
}
function useToken(contractAddress) {
  showDeprecationWarning(`useToken("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "token")`);
  return useContract(contractAddress, "token").contract;
}
function useTokenDrop(contractAddress) {
  showDeprecationWarning(`useTokenDrop("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "token-drop")`);
  return useContract(contractAddress, "token-drop").contract;
}
function useVote(contractAddress) {
  showDeprecationWarning(`useVote("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "vote")`);
  return useContract(contractAddress, "vote").contract;
}
function useSplit(contractAddress) {
  showDeprecationWarning(`useSplit("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "split")`);
  return useContract(contractAddress, "split").contract;
}
function useMultiwrap(contractAddress) {
  showDeprecationWarning(`useMultiwrap("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "multiwrap")`);
  return useContract(contractAddress, "multiwrap").contract;
}
function useSignatureDrop(contractAddress) {
  showDeprecationWarning(`useSignatureDrop("${contractAddress || "0x..."}")`, `useContract("${contractAddress || "0x..."}", "signature-drop")`);
  return useContract(contractAddress, "signature-drop").contract;
}
function getErcs(contract) {
  return {
    erc1155: getErc1155(contract),
    erc721: getErc721(contract),
    erc20: getErc20(contract)
  };
}
function getErc1155(contract) {
  if (!contract) {
    return void 0;
  }
  try {
    if ("erc1155" in contract) {
      return contract.erc1155;
    }
  } catch (error) {
    return void 0;
  }
  return void 0;
}
function getErc721(contract) {
  if (!contract) {
    return void 0;
  }
  try {
    if ("erc721" in contract) {
      return contract.erc721;
    }
  } catch (error) {
    return void 0;
  }
  return void 0;
}
function getErc20(contract) {
  if (!contract) {
    return void 0;
  }
  try {
    if ("erc20" in contract) {
      return contract.erc20;
    }
  } catch (error) {
    return void 0;
  }
  return void 0;
}
function useNFT(contract, tokenId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.get(contractAddress, tokenId), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant(erc1155.get, "Contract instance does not support get");
      return await erc1155.get(BigNumber.from(tokenId || 0));
    }
    if (erc721) {
      invariant(erc721.get, "Contract instance does not support get");
      return await erc721.get(BigNumber.from(tokenId || 0));
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && tokenId !== void 0
  });
}
function useNFTs(contract, queryParams) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.all(contractAddress, queryParams), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      invariant(erc721.getAll, "Contract instance does not support getAll");
      return await erc721.getAll(queryParams);
    }
    if (erc1155) {
      invariant(erc1155.getAll, "Contract instance does not support getAll");
      return await erc1155.getAll(queryParams);
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}
function useTotalCount(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCount(contractAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant(erc1155.totalCount, "Contract instance does not support totalCount");
      return await erc1155.totalCount();
    }
    if (erc721) {
      invariant(erc721.totalCount, "Contract instance does not support totalCount");
      return await erc721.totalCount();
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}
function useTotalCirculatingSupply(contract, tokenId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc1155) {
      invariant(erc1155.totalCirculatingSupply, "Contract instance does not support totalCirculatingSupply");
      requiredParamInvariant(tokenId, "No tokenId provided");
      return await erc1155.totalCirculatingSupply(tokenId);
    }
    if (erc721) {
      invariant(erc721.totalCirculatingSupply, "Contract instance does not support totalCirculatingSupply");
      return await erc721.totalCirculatingSupply();
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && tokenId !== void 0
  });
}
function useOwnedNFTs(contract, ownerWalletAddress) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(ownerWalletAddress, "No wallet address provided");
    if (erc721) {
      return await erc721.getOwned(ownerWalletAddress);
    }
    if (erc1155) {
      return await erc1155.getOwned(ownerWalletAddress);
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && !!ownerWalletAddress
  });
}
function useNFTBalance(contract, ownerWalletAddress, tokenId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.balanceOf(contractAddress, ownerWalletAddress, tokenId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(ownerWalletAddress, "No owner wallet address provided");
    if (erc1155) {
      requiredParamInvariant(tokenId, "No tokenId provided");
      invariant(erc1155.balanceOf, "Contract instance does not support balanceOf");
      return erc1155.balanceOf(ownerWalletAddress, tokenId);
    }
    if (erc721) {
      invariant(erc721.balanceOf, "Contract instance does not support balanceOf");
      return erc721.balanceOf(ownerWalletAddress);
    }
    invariant(false, "Unknown NFT type");
  }, {
    enabled: !!erc721 || !!erc1155 && !!ownerWalletAddress
  });
}
function useMintNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return useMutation(async (data) => {
    invariant(data.to, 'No "to" address provided');
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      invariant("supply" in data, "supply not provided");
      const {
        to,
        metadata,
        supply
      } = data;
      return await erc1155.mintTo(to, {
        metadata,
        supply: BigNumber.from(supply || 1)
      });
    }
    if (erc721) {
      return await erc721.mintTo(data.to, data.metadata);
    }
    invariant(false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useMintNFTSupply(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (data) => {
    invariant(data.to, 'No "to" address provided');
    requiredParamInvariant(contract, "contract is undefined");
    requiredParamInvariant(data.tokenId, "tokenId not provided");
    invariant("additionalSupply" in data, "additionalSupply not provided");
    const {
      to,
      tokenId,
      additionalSupply
    } = data;
    return await contract.mintAdditionalSupplyTo(to, tokenId, additionalSupply);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useTransferNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return useMutation((data) => {
    invariant("to" in data, "to not provided");
    if (erc1155) {
      invariant(erc1155.transfer, "contract does not support transfer");
      requiredParamInvariant(data.tokenId, "tokenId not provided");
      invariant("amount" in data, "amount not provided");
      return erc1155.transfer(data.to, data.tokenId, data.amount);
    }
    if (erc721) {
      return erc721.transfer(data.to, data.tokenId);
    }
    invariant(false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useAirdropNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation((_ref) => {
    let {
      tokenId,
      addresses
    } = _ref;
    requiredParamInvariant(contract, "contract is undefined");
    invariant(contract.airdrop, "contract does not support airdrop");
    return contract.airdrop(tokenId, addresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useBurnNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc1155,
    erc721
  } = getErcs(contract);
  return useMutation(async (data) => {
    requiredParamInvariant(data.tokenId, "No tokenId provided");
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      invariant("amount" in data, "amount not provided");
      const {
        tokenId,
        amount
      } = data;
      return await erc1155.burn(tokenId, amount);
    }
    if (erc721) {
      const {
        tokenId
      } = data;
      return await erc721.burn(tokenId);
    }
    invariant(false, "Unknown NFT type");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useUnclaimedNFTs(contract, queryParams) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(contract.getAllUnclaimed, "Contract instance does not support getAllUnclaimed");
    return contract.getAllUnclaimed(queryParams);
  }, {
    enabled: !!contract
  });
}
function useClaimedNFTs(contract, queryParams) {
  return useNFTs(contract, queryParams);
}
function useUnclaimedNFTSupply(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      invariant(erc721, "No ERC721 Contract instance provided");
      return erc721.totalUnclaimedSupply();
    }
    invariant(false, "Contract is not an instance of ERC721");
  }, {
    enabled: !!erc721
  });
}
function useClaimedNFTSupply(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc721) {
      return erc721.totalClaimedSupply();
    }
    invariant(false, "Contract is not an instance of ERC721");
  }, {
    enabled: !!erc721
  });
}
function useBatchesToReveal(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.revealer.getBatchesToReveal(contractAddress), () => {
    if (erc721) {
      return erc721.revealer.getBatchesToReveal();
    }
    if (erc1155) {
      return erc1155.revealer.getBatchesToReveal();
    }
    invariant(false, "Contract instance does not support getBatchesToReveal");
  }, {
    enabled: !!erc721 || !!erc1155
  });
}
function useClaimNFT(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useMutation(async (data) => {
    requiredParamInvariant(contract, "contract is undefined");
    if (erc1155) {
      requiredParamInvariant(data.tokenId, "tokenId not provided");
      if (!data.to) {
        return await erc1155.claim(data.tokenId, data.quantity, data.options);
      }
      return await erc1155.claimTo(data.to, data.tokenId, data.quantity, data.options);
    }
    if (erc721) {
      if (!data.to) {
        return await erc721.claim(data.quantity, data.options);
      }
      return await erc721.claimTo(data.to, data.quantity, data.options);
    }
    invariant(false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useLazyMint(contract, onProgress) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc721,
    erc1155
  } = getErcs(contract);
  return useMutation(async (data) => {
    requiredParamInvariant(contract, "contract is undefined");
    let options;
    if (onProgress) {
      options = {
        onProgress
      };
    }
    if (erc721) {
      return erc721.lazyMint(data.metadatas, options);
    }
    if (erc1155) {
      return erc1155.lazyMint(data.metadatas, options);
    }
    invariant(false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useDelayedRevealLazyMint(contract, onProgress) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (data) => {
    requiredParamInvariant(contract, "contract is undefined");
    let options;
    if (onProgress) {
      options = {
        onProgress
      };
    }
    const {
      erc721,
      erc1155
    } = getErcs(contract);
    if (erc721) {
      return await erc721.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);
    }
    if (erc1155) {
      return await erc1155.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);
    }
    invariant(false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useRevealLazyMint(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (data) => {
    requiredParamInvariant(contract, "contract is undefined");
    const {
      erc721,
      erc1155
    } = getErcs(contract);
    if (erc721) {
      return await erc721.revealer.reveal(data.batchId, data.password);
    }
    if (erc1155) {
      return await erc1155.revealer.reveal(data.batchId, data.password);
    }
    invariant(false, "contract is not an Erc721 or Erc1155");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useListing(contract, listingId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getListing(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    return contract.getListing(listingId);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}
function useListings(contract, filter) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getAllListings(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getAllListings(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}
function useListingsCount(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getTotalCount(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getTotalCount();
  }, {
    enabled: !!contract
  });
}
function useActiveListings(contract, filter) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getActiveListings(filter);
  }, {
    enabled: !!contract,
    keepPreviousData: true
  });
}
function useWinningBid(contract, listingId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinningBid(contractAddress, listingId), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    return contract.auction.getWinningBid(listingId);
  }, {
    enabled: !!contract && listingId !== void 0
  });
}
function useAuctionWinner(contract, listingId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinner(contractAddress, listingId), async () => {
    var _a;
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    let winner;
    try {
      winner = await contract.auction.getWinner(listingId);
    } catch (err) {
      if (!((_a = err == null ? void 0 : err.message) == null ? void 0 : _a.includes("Could not find auction"))) {
        throw err;
      }
    }
    return winner;
  }, {
    enabled: !!contract && listingId !== void 0
  });
}
function useBidBuffer(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getBidBufferBps(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    return contract.getBidBufferBps();
  }, {
    enabled: !!contract
  });
}
function useMinimumNextBid(contract, listingId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinner(contractAddress, listingId), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    requiredParamInvariant(listingId, "No listing id provided");
    return await contract.auction.getMinimumNextBid(listingId);
  }, {
    enabled: !!contract && listingId !== void 0
  });
}
function useCreateDirectListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(contract.direct.createListing, "contract does not support direct.createListing");
    return await contract.direct.createListing(data);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useCreateAuctionListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot create listing");
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(contract.direct.createListing, "contract does not support auction.createListing");
    return await contract.auction.createListing(data);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useCancelListing(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (data) => {
    if (data.type === ListingType.Auction) {
      return await (contract == null ? void 0 : contract.auction.cancelListing(data.id));
    } else {
      return await (contract == null ? void 0 : contract.direct.cancelListing(data.id));
    }
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useMakeBid(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(contract.auction.makeBid, "contract does not support auction.makeBid");
    return await contract.auction.makeBid(data.listingId, data.bid);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useMakeOffer(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    return await contract.makeOffer(data.listingId, data.pricePerToken, data.quantity);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useAcceptDirectListingOffer(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract == null ? void 0 : contract.direct, "No Direct instance provided");
    return await contract.direct.acceptOffer(data.listingId, data.addressOfOfferor);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useExecuteAuctionSale(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract == null ? void 0 : contract.auction, "No Auction marketplace instance provided");
    return await contract.auction.executeSale(data.listingId);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useOffers(contract, listingId) {
  var _a, _b;
  const result = useContractEvents(contract, "NewOffer");
  return {
    ...result,
    data: (_b = (_a = result.data) == null ? void 0 : _a.filter((ev) => ev.data.listingId.eq(listingId))) == null ? void 0 : _b.map((ev) => ev.data)
  };
}
function useBuyNow(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const walletAddress = useAddress();
  return useMutation(async (data) => {
    invariant(walletAddress, "no wallet connected, cannot make bid");
    requiredParamInvariant(contract, "No Contract instance provided");
    if (data.type === ListingType.Direct) {
      invariant(contract.direct.buyoutListing, "contract does not support direct.buyoutListing");
      return await contract.direct.buyoutListing(data.id, data.buyAmount, data.buyForWallet);
    }
    invariant(contract.auction.buyoutListing, "contract does not support auction.buyoutListing");
    return await contract.auction.buyoutListing(data.id);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useTokenSupply(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.totalSupply(contractAddress), () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    const erc20 = getErc20(contract);
    if (erc20) {
      return erc20.totalSupply();
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!contract || !!contractAddress
  });
}
function useTokenBalance(contract, walletAddress) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const erc20 = getErc20(contract);
  return useQueryWithNetwork(cacheKeys.contract.token.balanceOf(contractAddress, walletAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    invariant(walletAddress, "No address provided");
    if (erc20) {
      return await erc20.balanceOf(walletAddress);
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!walletAddress && !!contract
  });
}
function useTokenDecimals(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const erc20 = getErc20(contract);
  return useQueryWithNetwork(cacheKeys.contract.token.decimals(contractAddress), async () => {
    requiredParamInvariant(contract, "No Contract instance provided");
    if (erc20) {
      return (await erc20.get()).decimals;
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    enabled: !!contract
  });
}
function useMintToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const erc20 = getErc20(contract);
  return useMutation((data) => {
    const {
      to,
      amount
    } = data;
    requiredParamInvariant(contract, "contract is undefined");
    if (erc20) {
      return erc20.mintTo(to, amount);
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useClaimToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const erc20 = getErc20(contract);
  return useMutation(async (data) => {
    invariant(data.to, 'No "to" address provided');
    if (erc20) {
      invariant(erc20 == null ? void 0 : erc20.claimTo, "contract does not support claimTo");
      return await erc20.claimTo(data.to, data.amount, {
        checkERC20Allowance: data.checkERC20Allowance
      });
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useTransferToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const erc20 = getErc20(contract);
  return useMutation((data) => {
    const {
      to,
      amount
    } = data;
    if (erc20) {
      invariant(erc20 == null ? void 0 : erc20.transfer, "contract does not support transfer");
      return erc20.transfer(to, amount);
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useTransferBatchToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const erc20 = getErc20(contract);
  return useMutation((data) => {
    if (erc20) {
      invariant(erc20.transferBatch, "contract does not support transferBatch");
      const convertedData = data.map((token) => ({
        toAddress: token.to,
        amount: token.amount
      }));
      return erc20.transferBatch(convertedData);
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useBurnToken(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const erc20 = getErc20(contract);
  return useMutation((data) => {
    const {
      amount
    } = data;
    requiredParamInvariant(contract, "contract is undefined");
    if (erc20) {
      invariant(erc20.burn, "contract does not support burn");
      return erc20.burn(amount);
    }
    invariant(false, "Smart contract is not a valid erc20 contract");
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useActiveClaimCondition(contract, tokenId, options) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId, options), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getActive(tokenId, options);
    }
    if (erc721) {
      return erc721.claimConditions.getActive(options);
    }
    if (erc20) {
      return erc20.claimConditions.getActive(options);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== void 0 : !!erc721 || !!erc20
  });
}
function useClaimerProofs(contract, claimerAddress, tokenId, claimConditionId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimerProofs(contractAddress, tokenId), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getClaimerProofs(tokenId, claimerAddress, claimConditionId);
    }
    if (erc721) {
      return erc721.claimConditions.getClaimerProofs(claimerAddress, claimConditionId);
    }
    if (erc20) {
      return erc20.claimConditions.getClaimerProofs(claimerAddress, claimConditionId);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== void 0 : !!erc721 || !!erc20
  });
}
function useClaimConditions(contract, tokenId, options) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId, options), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.getAll(tokenId, options);
    }
    if (erc721) {
      return erc721.claimConditions.getAll(options);
    }
    if (erc20) {
      return erc20.claimConditions.getAll(options);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== void 0 : !!erc721 || !!erc20
  });
}
function useClaimIneligibilityReasons(contract, params, tokenId) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(contractAddress, params, tokenId), () => {
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim ineligibility reasons");
      return erc1155.claimConditions.getClaimIneligibilityReasons(tokenId, params.quantity, params.walletAddress);
    }
    if (erc721) {
      return erc721.claimConditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
    }
    if (erc20) {
      return erc20.claimConditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    // 3. has a params object been passed?
    // 4. does params have an address in it?
    enabled: (erc1155 ? tokenId !== void 0 : !!erc721 || !!erc20) && !!params && !!params.walletAddress
  });
}
function useActiveClaimConditionForWallet(contract, walletAddress, tokenId) {
  const sdk = useSDK();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.useActiveClaimConditionForWallet(contractAddress, walletAddress || "_NO_WALLET_", tokenId), async () => {
    if (!walletAddress) {
      if (erc1155) {
        requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
        return erc1155.claimConditions.getActive(tokenId);
      }
      if (erc721) {
        return erc721.claimConditions.getActive();
      }
      if (erc20) {
        return erc20.claimConditions.getActive();
      }
      throw new Error("Contract must be ERC721, ERC1155 or ERC20");
    }
    invariant(sdk, "sdk is required");
    let activeGeneralClaimCondition = null;
    let claimerProofForWallet = null;
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155");
      const [cc, cp] = await Promise.all([erc1155.claimConditions.getActive(tokenId), erc1155.claimConditions.getClaimerProofs(tokenId, walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    if (erc721) {
      const [cc, cp] = await Promise.all([erc721.claimConditions.getActive(), erc721.claimConditions.getClaimerProofs(walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    if (erc20) {
      const [cc, cp] = await Promise.all([erc20.claimConditions.getActive(), erc20.claimConditions.getClaimerProofs(walletAddress)]);
      activeGeneralClaimCondition = cc;
      claimerProofForWallet = cp;
    }
    if (!activeGeneralClaimCondition) {
      return null;
    }
    if (!claimerProofForWallet) {
      return activeGeneralClaimCondition;
    }
    const {
      maxClaimable,
      currencyAddress,
      price
    } = claimerProofForWallet;
    const currencyWithOverride = currencyAddress || activeGeneralClaimCondition.currencyAddress;
    const currencyMetadata = await fetchCurrencyMetadata(sdk.getProvider(), currencyWithOverride);
    const normalizedPrize = price ? price === "unlimited" ? lib_exports7.MaxUint256 : utils_exports.parseUnits(price, currencyMetadata.decimals) : null;
    const priceWithOverride = normalizedPrize || activeGeneralClaimCondition.price;
    const maxClaimableWithOverride = (
      // have to transform this the same way that claim conditions do it in SDK
      convertToReadableQuantity(maxClaimable, currencyMetadata.decimals) || activeGeneralClaimCondition.maxClaimablePerWallet
    );
    const currencyValueWithOverride = await fetchCurrencyValue(sdk.getProvider(), currencyWithOverride, priceWithOverride);
    return {
      // inherit the entire claim condition
      ...activeGeneralClaimCondition,
      // overwrite all keys that could be changed based on overwrites
      maxClaimablePerWallet: maxClaimableWithOverride,
      price: priceWithOverride,
      currency: currencyWithOverride,
      currencyAddress: currencyWithOverride,
      currencyMetadata: currencyValueWithOverride
    };
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => we have to have either an ERC721 or ERC20 contract
    enabled: erc1155 ? tokenId !== void 0 : !!erc721 || !!erc20
  });
}
function useSetClaimConditions(contract, tokenId) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useMutation(async (data) => {
    requiredParamInvariant(contract, "No Contract instance provided");
    const {
      phases,
      reset = false
    } = data;
    invariant(phases, 'No "phases" provided');
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return erc1155.claimConditions.set(tokenId, phases, reset);
    }
    if (erc721) {
      return erc721.claimConditions.set(phases, reset);
    }
    if (erc20) {
      return erc20.claimConditions.set(phases, reset);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
function useResetClaimConditions(contract, tokenId) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  const {
    erc1155,
    erc721,
    erc20
  } = getErcs(contract);
  return useMutation(async () => {
    const cleanConditions = async (conditions) => {
      return conditions.map((c2) => ({
        ...c2,
        price: c2.currencyMetadata.displayValue
      }));
    };
    if (erc1155) {
      requiredParamInvariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      const claimConditions = await erc1155.claimConditions.getAll(tokenId, {
        withAllowList: true
      });
      return erc1155.claimConditions.set(tokenId, await cleanConditions(claimConditions || []), true);
    }
    if (erc721) {
      const claimConditions = await erc721.claimConditions.getAll({
        withAllowList: true
      });
      return await erc721.claimConditions.set(await cleanConditions(claimConditions || []), true);
    }
    if (erc20) {
      const claimConditions = await erc20.claimConditions.getAll({
        withAllowList: true
      });
      return await erc20.claimConditions.set(await cleanConditions(claimConditions || []), true);
    }
    throw new Error("Contract must be ERC721, ERC1155 or ERC20");
  }, {
    onSettled: () => {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
function usePrimarySaleRecipient(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.sales.getRecipient(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.getRecipient();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
function useUpdatePrimarySaleRecipient(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const activeChainId = useSDKChainId();
  return useMutation((newRecipient) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.setRecipient(newRecipient);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useRoyaltySettings(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.royalties.getDefaultRoyaltyInfo(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.getDefaultRoyaltyInfo();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
function useUpdateRoyaltySettings(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const activeChainId = useSDKChainId();
  return useMutation((updatePayload) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.setDefaultRoyaltyInfo(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function usePlatformFees(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.platformFees.get(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
function useUpdatePlatformFees(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const activeChainId = useSDKChainId();
  return useMutation((updatePayload) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.set(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useMetadata(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.metadata.get(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
function useUpdateMetadata(contract) {
  const queryClient = useQueryClient();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const activeChainId = useSDKChainId();
  return useMutation((updatePayload) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.update(updatePayload);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useAllRoleMembers(contract) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.getAll(contractAddress), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    return contract.roles.getAll();
  }, {
    enabled: !!contract && !!contractAddress
  });
}
function useRoleMembers(contract, role) {
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.get(contractAddress, role), () => {
    requiredParamInvariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    return contract.roles.get(role);
  }, {
    enabled: !!contract && !!contractAddress && !!role
  });
}
function useIsAddressRole(contract, role, walletAddress) {
  const contractHasRoles = !!(contract && contract.roles);
  const {
    data
  } = useRoleMembers(contractHasRoles ? contract : void 0, role);
  if (contractHasRoles === false) {
    return true;
  }
  if (data == null ? void 0 : data.includes(lib_exports7.AddressZero)) {
    return true;
  }
  return !!(walletAddress && (data == null ? void 0 : data.includes(walletAddress)));
}
function useSetAllRoleMembers(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (rolesWithAddresses) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.setAll(rolesWithAddresses);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useGrantRole(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (params) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.grant(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useRevokeRole(contract) {
  const activeChainId = useSDKChainId();
  const contractAddress = contract == null ? void 0 : contract.getAddress();
  const queryClient = useQueryClient();
  return useMutation(async (params) => {
    requiredParamInvariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    await contract.roles.revoke(params.role, params.address);
  }, {
    onSettled: () => invalidateContractAndBalances(queryClient, contractAddress, activeChainId)
  });
}
function useLogin(config) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const authConfig = useThirdwebAuthConfig();
  import_react6.default.useEffect(() => {
    const queryParams = new URLSearchParams(window.location.search);
    const error = queryParams.get("error");
    if (error && (config == null ? void 0 : config.onError)) {
      config.onError(decodeURI(error));
    }
  }, [config]);
  async function login(cfg) {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    const payload = await (sdk == null ? void 0 : sdk.auth.login(authConfig.domain, cfg));
    const encodedPayload = encodeURIComponent(btoa(JSON.stringify(payload)));
    const encodedRedirectTo = encodeURIComponent((config == null ? void 0 : config.redirectTo) || authConfig.loginRedirect || window.location.toString());
    queryClient.invalidateQueries(cacheKeys.auth.user());
    window.location.href = `${authConfig.authUrl}/login?payload=${encodedPayload}&redirect=${encodedRedirectTo}`;
  }
  return login;
}
function useLogout() {
  const queryClient = useQueryClient();
  const authConfig = useThirdwebAuthConfig();
  function logout() {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    queryClient.invalidateQueries(cacheKeys.auth.user());
    window.location.href = `${authConfig.authUrl}/logout`;
  }
  return logout;
}
function useUser() {
  const authConfig = useThirdwebAuthConfig();
  const {
    data: user,
    isLoading
  } = useQuery(cacheKeys.auth.user(), async () => {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    const res = await fetch(`${authConfig.authUrl}/user`, {
      credentials: "include"
    });
    return await res.json();
  }, {
    enabled: !!authConfig
  });
  return {
    user,
    isLoading
  };
}
function useAuth(loginConfig) {
  const user = useUser();
  const login = useLogin(loginConfig);
  const logout = useLogout();
  return {
    ...user,
    login,
    logout
  };
}
function useStorageUpload(uploadOptions) {
  const sdk = useSDK();
  return useMutation(async (_ref) => {
    let {
      data,
      options
    } = _ref;
    invariant(sdk, "sdk must be defined");
    return await sdk.storage.uploadBatch(data, options || uploadOptions);
  });
}
function useStorage() {
  const sdk = useSDK();
  return sdk == null ? void 0 : sdk.storage;
}
function useSigner2() {
  return useThirdwebConnectedWalletContext().signer;
}
function useReadonlySDK(readonlyRpcUrl, sdkOptions, storageInterface) {
  return (0, import_react6.useMemo)(() => {
    return new ThirdwebSDK(readonlyRpcUrl, {
      ...sdkOptions,
      readonlySettings: {
        ...sdkOptions == null ? void 0 : sdkOptions.readonlySettings,
        rpcUrl: readonlyRpcUrl
      }
    }, storageInterface);
  }, [readonlyRpcUrl, sdkOptions]);
}
function useNetworkMismatch() {
  const desiredChainId = useDesiredChainId();
  const walletChainId = useChainId();
  if (desiredChainId === -1) {
    return false;
  }
  if (!walletChainId) {
    return false;
  }
  return desiredChainId !== walletChainId;
}
function useAccount2() {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useNetwork() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own network logic.`);
  return useAccount();
}
function useNetwork2() {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useNetwork() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own network logic.`);
  return useNetwork();
}
function useDisconnect(options) {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useDisconnect() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own connection logic.`);
  const optsWithDefaults = {
    ...{
      reconnectPrevious: true
    },
    ...options
  };
  const [, connect2] = useConnect2();
  const [data, disconnect] = useAccount();
  return async () => {
    var _a, _b;
    const previousConnector = ((_b = (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.connector) == null ? void 0 : _b.previousConnector) || void 0;
    if (optsWithDefaults.reconnectPrevious && previousConnector) {
      try {
        return await connect2(previousConnector);
      } catch (err) {
        console.error("failed to re-connect to previous connector", err);
        return disconnect();
      }
    }
    return disconnect();
  };
}
function detectEnv(userAgent) {
  return detect(userAgent);
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function detectOS2() {
  const env = detectEnv();
  return (env == null ? void 0 : env.os) ? env.os : void 0;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function useMetamask() {
  var _a;
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useMetamask() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own wallet-connection logic.`);
  const [connectors, connect2] = useConnect2();
  const isMetaMaskInjected = typeof window !== "undefined" && ((_a = window.ethereum) == null ? void 0 : _a.isMetaMask);
  const shouldUseWalletConnect = isMobile() && !isMetaMaskInjected;
  const injectedConnector = connectors.data.connectors.find((c2) => c2.id === "injected");
  const walletConnectConnector = connectors.data.connectors.find((c2) => c2.id === "walletConnect");
  const connector = (shouldUseWalletConnect ? walletConnectConnector : injectedConnector) || injectedConnector;
  invariant(connector, "No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />");
  return async () => {
    if (!isMetaMaskInjected) {
      const uri = `https://metamask.app.link/dapp/${window.location.toString()}`;
      window.open(uri, "_blank");
      return Promise.resolve({
        error: new Error("metamask not injected")
      });
    }
    return await connect2(connector);
  };
}
globalThis.Buffer = import_buffer.Buffer;
function useWalletConnect() {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useWalletConnect() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own wallet-connection logic.`);
  const [connectors, connect2] = useConnect2();
  if (connectors.loading) {
    return () => Promise.reject("WalletConnect connector not ready to be used, yet");
  }
  const connector = connectors.data.connectors.find((c2) => c2.id === "walletConnect");
  invariant(connector, "WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return () => connect2(connector);
}
globalThis.Buffer = import_buffer.Buffer;
function useCoinbaseWallet() {
  const wagmiContext = useContext2();
  invariant(wagmiContext, `useCoinbaseWallet() can only be used inside <ThirdwebProvider />. If you are using <ThirdwebSDKProvider /> you will have to use your own wallet-connection logic.`);
  const [connectors, connect2] = useConnect2();
  if (connectors.loading) {
    return () => Promise.reject("Coinbase connector not ready to be used, yet");
  }
  const connector = connectors.data.connectors.find((c2) => c2.id === "coinbasewallet");
  invariant(connector, "Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return () => connect2(connector);
}
function useWalletLink() {
  return useCoinbaseWallet();
}
var DEFAULT_IPFS_GATEWAY2 = "https://gateway.ipfscdn.io/ipfs/";
var DEFAULT_IPFS_RESOLVER_OPTIONS = {
  gatewayUrl: DEFAULT_IPFS_GATEWAY2
};
function resolveIpfsUri(uri) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_IPFS_RESOLVER_OPTIONS;
  if (!uri) {
    return void 0;
  }
  if (uri.startsWith("ipfs://")) {
    return uri.replace("ipfs://", options.gatewayUrl);
  }
  return uri;
}
async function resolveMimeType(url) {
  if (!url) {
    return void 0;
  }
  const mimeType = import_lite.default.getType(url);
  if (mimeType) {
    return mimeType;
  }
  const res = await fetch(url, {
    method: "HEAD"
  });
  if (res.ok && res.headers.has("content-type")) {
    return res.headers.get("content-type") || void 0;
  }
  return void 0;
}
var video;
function supportsVideoType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("video/")) {
    return "";
  }
  if (!video) {
    video = document.createElement("video");
  }
  return video.canPlayType(mimeType);
}
function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
var audio;
function supportsAudioType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }
  if (!audio) {
    audio = document.createElement("audio");
  }
  return audio.canPlayType(mimeType);
}
function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}
function mergeRefs(refs) {
  return (value) => {
    refs.forEach((ref2) => {
      if (typeof ref2 === "function") {
        ref2(value);
      } else if (ref2 != null) {
        ref2.current = value;
      }
    });
  };
}
var CarbonDocumentUnknown = (props) => {
  return (0, import_jsx_runtime2.jsxs)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [(0, import_jsx_runtime2.jsx)("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), (0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), (0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
var CarbonDocumentAudio = (props) => {
  return (0, import_jsx_runtime2.jsxs)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [(0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), (0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
var CarbonPauseFilled = (props) => {
  return (0, import_jsx_runtime2.jsx)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: (0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
var CarbonPlayFilledAlt = (props) => {
  return (0, import_jsx_runtime2.jsx)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: (0, import_jsx_runtime2.jsx)("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};
var PlayButton = (_ref) => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = (0, import_react6.useState)(false);
  const onMouseEnter = () => setIsHovering(true);
  const onMouseLeave = () => setIsHovering(false);
  const onMouseDown = () => setIsHovering(false);
  const onMouseUp = () => setIsHovering(true);
  return (0, import_jsx_runtime2.jsx)("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {}
    },
    onClick,
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onMouseUp,
    children: !isPlaying ? (0, import_jsx_runtime2.jsx)(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : (0, import_jsx_runtime2.jsx)(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};
var VideoPlayer = import_react6.default.forwardRef((_ref2, ref2) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = (0, import_react6.useRef)(null);
  const [playing, setPlaying] = (0, import_react6.useState)(!requireInteraction);
  const [muted, setMuted] = (0, import_react6.useState)(true);
  (0, import_react6.useEffect)(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return (0, import_jsx_runtime2.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [(0, import_jsx_runtime2.jsx)("video", {
      ref: mergeRefs([videoRef, ref2]),
      src: src ?? void 0,
      poster: poster ?? void 0,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        var _a;
        if (playing) {
          (_a = videoRef.current) == null ? void 0 : _a.play();
        }
      },
      width,
      height,
      controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && (0, import_jsx_runtime2.jsx)("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), (0, import_jsx_runtime2.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
var AudioPlayer = import_react6.default.forwardRef((_ref3, ref2) => {
  let {
    src,
    alt,
    poster,
    style,
    height,
    width,
    ...restProps
  } = _ref3;
  const audioRef = (0, import_react6.useRef)(null);
  const [playing, setPlaying] = (0, import_react6.useState)(false);
  const [muted, setMuted] = (0, import_react6.useState)(true);
  (0, import_react6.useEffect)(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return (0, import_jsx_runtime2.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? (0, import_jsx_runtime2.jsx)("img", {
      height,
      width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt
    }) : (0, import_jsx_runtime2.jsx)("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: (0, import_jsx_runtime2.jsx)(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), (0, import_jsx_runtime2.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
        setMuted(false);
      },
      isPlaying: playing
    }), (0, import_jsx_runtime2.jsx)("audio", {
      ref: mergeRefs([audioRef, ref2]),
      src: src ?? void 0,
      loop: true,
      playsInline: true,
      muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
var IframePlayer = import_react6.default.forwardRef((_ref4, ref2) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    ...restProps
  } = _ref4;
  const {
    observe,
    width: elWidth
  } = index_esm_default();
  const [playing, setPlaying] = (0, import_react6.useState)(!requireInteraction);
  if (elWidth < 300) {
    return (0, import_jsx_runtime2.jsx)("div", {
      ref: observe,
      children: (0, import_jsx_runtime2.jsx)(LinkPlayer, {
        style,
        src,
        alt,
        ...restProps
      })
    });
  }
  return (0, import_jsx_runtime2.jsxs)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    ref: observe,
    children: [(0, import_jsx_runtime2.jsx)("iframe", {
      src: playing ? src ?? void 0 : void 0,
      ref: ref2,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && (0, import_jsx_runtime2.jsx)("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), (0, import_jsx_runtime2.jsx)(PlayButton, {
      onClick: () => {
        setPlaying((prev) => !prev);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
var LinkPlayer = import_react6.default.forwardRef((_ref5, ref2) => {
  let {
    src,
    alt,
    style,
    ...restProps
  } = _ref5;
  return (0, import_jsx_runtime2.jsx)("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: (0, import_jsx_runtime2.jsx)("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: (0, import_jsx_runtime2.jsxs)("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [(0, import_jsx_runtime2.jsx)(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), (0, import_jsx_runtime2.jsx)("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src ?? void 0,
          target: "_blank",
          ref: ref2,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";
var MediaRenderer = import_react6.default.forwardRef((_ref6, ref2) => {
  let {
    src,
    poster,
    alt,
    requireInteraction = false,
    style,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src ?? void 0);
  const possiblePosterSrc = useResolvedMediaType(poster ?? void 0);
  if (!videoOrImageSrc.mimeType) {
    return (0, import_jsx_runtime2.jsx)("img", {
      style: mergedStyle,
      ...restProps,
      ref: ref2,
      alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return (0, import_jsx_runtime2.jsx)(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return (0, import_jsx_runtime2.jsx)(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return (0, import_jsx_runtime2.jsx)(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return (0, import_jsx_runtime2.jsx)("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt,
      ref: ref2,
      ...restProps
    });
  }
  return (0, import_jsx_runtime2.jsx)(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt,
    ref: ref2,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";
function useResolvedMediaType(uri) {
  const resolvedUrl = (0, import_react6.useMemo)(() => resolveIpfsUri(uri), [uri]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}
var ThirdwebNftMedia = import_react6.default.forwardRef((_ref, ref2) => {
  var _a;
  let {
    metadata,
    ...props
  } = _ref;
  return (0, import_jsx_runtime2.jsx)(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: ((_a = metadata.name) == null ? void 0 : _a.toString()) || "",
    ref: ref2,
    ...props
  });
});
ThirdwebNftMedia.displayName = "ThirdwebNftMedia";
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function useForceUpdate() {
  const [, dispatch] = (0, import_react6.useState)(/* @__PURE__ */ Object.create(null));
  return (0, import_react6.useCallback)(() => {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
var useIsomorphicLayoutEffect = canUseDOM() ? import_react6.useLayoutEffect : import_react6.useEffect;
var PortalImpl = (_ref) => {
  let {
    children,
    type = "reach-portal",
    containerRef
  } = _ref;
  const mountNode = (0, import_react6.useRef)(null);
  const portalNode = (0, import_react6.useRef)(null);
  const forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(() => {
    if (!mountNode.current) {
      return;
    }
    const ownerDocument = mountNode.current.ownerDocument;
    const body = (containerRef == null ? void 0 : containerRef.current) || ownerDocument.body;
    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);
    body.appendChild(portalNode.current);
    forceUpdate();
    return () => {
      if (portalNode.current && body) {
        body.removeChild(portalNode.current);
      }
    };
  }, [type, forceUpdate, containerRef]);
  return portalNode.current ? (0, import_react_dom2.createPortal)(children, portalNode.current) : (0, import_jsx_runtime2.jsx)("span", {
    ref: mountNode
  });
};
var Portal2 = (_ref2) => {
  let {
    unstable_skipInitialRender,
    ...props
  } = _ref2;
  const [hydrated, setHydrated] = (0, import_react6.useState)(false);
  (0, import_react6.useEffect)(() => {
    if (unstable_skipInitialRender) {
      setHydrated(true);
    }
  }, [unstable_skipInitialRender]);
  if (unstable_skipInitialRender && !hydrated) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(PortalImpl, {
    ...props
  });
};
Portal2.displayName = "Portal";
function shortenString(str, extraShort) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}
function shortenAddress(address, extraShort) {
  try {
    const formattedAddress = utils_exports.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}
function shortenIfAddress(address, extraShort) {
  if (typeof address === "string" && address.length > 0) {
    return shortenAddress(address, extraShort);
  }
  return address || "";
}
function useClipboard(text) {
  let optionsOrTimeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const [hasCopied, setHasCopied] = (0, import_react6.useState)(false);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = (0, import_react6.useCallback)(() => {
    const didCopy = (0, import_copy_to_clipboard.default)(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  (0, import_react6.useEffect)(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}
var Box = emotion_styled_browser_esm_default.div``;
var spin = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = emotion_styled_browser_esm_default.div`
  display: inline-block;
  border-top: 2px solid currentcolor;
  border-right: 2px solid currentcolor;
  border-bottom-style: solid;
  border-left-style: solid;
  border-radius: 99999px;
  border-bottom-width: 2px;
  border-left-width: 2px;
  border-bottom-color: transparent;
  border-left-color: transparent;
  animation: 0.45s linear 0s infinite normal none running ${spin};
  width: 0.75em;
  height: 0.75em;
  flex-shrink: 0;
`;
var BaseButton = emotion_styled_browser_esm_default.button`
  position: relative;
  border-radius: 0.5em;
  padding: 0.75em 1.25em;
  padding-right: ${(props) => props.hasRightElement ? "0.75em" : "1.25em"};
  padding-left: ${(props) => props.hasLeftElement ? "0.75em" : "1.25em"};
  font-size: 1em;
  font-weight: 600;
  letter-spacing: 0.5px;
  display: flex;
  gap: 0.5em;
  align-items: center;
  justify-content: space-evenly;
  color: ${(props) => computeTextColorBasedOnBackground(props.theme.colors.accent)};
  border: 2px solid
    ${(props) => computeHoverColor(props.theme.colors.accent)};
  &:hover {
    cursor: pointer;
  }
  &:disabled {
    cursor: not-allowed;
  }
  &:focus {
    position: relative;
    border-radius: 0.5em;
    outline: 0;
  }
  &:focus:after {
    content: "";
    position: absolute;
    top: -5px;
    right: -5px;
    bottom: -5px;
    left: -5px;
    border: 2px solid ${(props) => props.theme.colors.accent};
    border-radius: 11px;
  }
`;
function computeHoverColor(c2) {
  const col = (0, import_color.default)(c2);
  if (col.hex() === "#000000") {
    return "#262627";
  }
  if (col.luminosity() < 0.2) {
    return col.lighten(0.1).hex();
  }
  return col.darken(0.1).hex();
}
function computeDisabledColor(c2) {
  const col = (0, import_color.default)(c2);
  if (col.hex() === "#000000") {
    return "#262627";
  }
  if (col.luminosity() < 0.2) {
    return col.lighten(0.5).hex();
  }
  return col.darken(0.5).hex();
}
function computeTextColorBasedOnBackground(c2) {
  const col = (0, import_color.default)(c2);
  if (col.isDark()) {
    return "#fff";
  }
  return "#000";
}
var SolidButton = emotion_styled_browser_esm_default(BaseButton)`
  background: ${(props) => props.theme.colors.accent};
  &:hover {
    background: ${(props) => computeHoverColor(props.theme.colors.accent)};
    border-color: ${(props) => computeHoverColor(props.theme.colors.accent)};
  }
  &:disabled {
    background: ${(props) => computeDisabledColor(props.theme.colors.accent)};
    border-color: ${(props) => computeDisabledColor(props.theme.colors.accent)};
    color: ${(props) => computeTextColorBasedOnBackground(computeDisabledColor(props.theme.colors.accent))};
  }
`;
var OutlineButton = emotion_styled_browser_esm_default(BaseButton)`
  background: transparent;
  &:hover {
    background: ${(props) => (0, import_color.default)(props.theme.colors.background).alpha(0.5).hexa()};
  }
`;
var Button = (_ref) => {
  let {
    children,
    variant,
    rightElement,
    leftElement,
    isLoading,
    isDisabled,
    disabled,
    ...restProps
  } = _ref;
  const Btn = variant === "outline" ? OutlineButton : SolidButton;
  return (0, import_jsx_runtime2.jsxs)(Btn, {
    ...restProps,
    disabled: isDisabled || disabled || isLoading,
    hasRightElement: !!rightElement,
    hasLeftElement: !!leftElement,
    children: [isLoading ? (0, import_jsx_runtime2.jsx)(Spinner, {
      style: {
        position: "absolute",
        left: "calc(50% - 0.75em / 2)"
      }
    }) : null, (0, import_jsx_runtime2.jsxs)("span", {
      style: {
        opacity: isLoading ? 0 : 1,
        display: "inherit",
        gap: "inherit",
        alignItems: "inherit",
        justifyContent: "inherit",
        width: "100%"
      },
      children: [leftElement, children, rightElement]
    })]
  });
};
var chainLogos = {
  ethereum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("path", {
        fill: "#25292E",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "url(#a)",
        fillOpacity: ".3",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "url(#b)",
        d: "M8.19 14.77 14 18.21l5.8-3.44-5.8 8.19-5.81-8.19Z"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "#fff",
        d: "m14 16.93-5.81-3.44L14 4.34l5.81 9.15L14 16.93Z"
      }), (0, import_jsx_runtime2.jsxs)("defs", {
        children: [(0, import_jsx_runtime2.jsxs)("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [(0, import_jsx_runtime2.jsx)("stop", {
            stopColor: "#fff"
          }), (0, import_jsx_runtime2.jsx)("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        }), (0, import_jsx_runtime2.jsxs)("linearGradient", {
          id: "b",
          x1: "14",
          x2: "14",
          y1: "14.77",
          y2: "22.96",
          gradientUnits: "userSpaceOnUse",
          children: [(0, import_jsx_runtime2.jsx)("stop", {
            stopColor: "#fff"
          }), (0, import_jsx_runtime2.jsx)("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: ".9"
          })]
        })]
      })]
    })
  },
  arbitrum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("rect", {
        width: "26.6",
        height: "26.6",
        x: ".7",
        y: ".7",
        fill: "#2D374B",
        stroke: "#96BEDC",
        strokeWidth: "1.4",
        rx: "13.3"
      }), (0, import_jsx_runtime2.jsx)("mask", {
        id: "a",
        width: "28",
        height: "28",
        x: "0",
        y: "0",
        maskUnits: "userSpaceOnUse",
        style: {
          maskType: "alpha"
        },
        children: (0, import_jsx_runtime2.jsx)("rect", {
          width: "28",
          height: "28",
          fill: "#C4C4C4",
          rx: "14"
        })
      }), (0, import_jsx_runtime2.jsxs)("g", {
        mask: "url(#a)",
        children: [(0, import_jsx_runtime2.jsx)("path", {
          fill: "#28A0F0",
          d: "m14.0861 18.6041 6.5014 10.2239 4.0057-2.3213-7.86-12.3943-2.6471 4.4917Zm13.0744 3.4692-.003-1.8599-7.3064-11.407-2.3087 3.9173 7.091 11.4303 2.172-1.2586a.9628.9628 0 0 0 .3555-.7009l-.0004-.1212Z"
        }), (0, import_jsx_runtime2.jsx)("rect", {
          width: "25.9",
          height: "25.9",
          x: "1.05",
          y: "1.05",
          fill: "url(#b)",
          fillOpacity: ".3",
          stroke: "#96BEDC",
          strokeWidth: "2.1",
          rx: "12.95"
        }), (0, import_jsx_runtime2.jsx)("path", {
          fill: "#fff",
          d: "m.3634 28.2207-3.07-1.7674-.234-.8333L7.7461 9.0194c.7298-1.1913 2.3197-1.575 3.7957-1.5541l1.7323.0457L.3634 28.2207ZM19.1655 7.511l-4.5653.0166L2.24 27.9533l3.6103 2.0788.9818-1.6652L19.1655 7.511Z"
        })]
      }), (0, import_jsx_runtime2.jsx)("defs", {
        children: (0, import_jsx_runtime2.jsxs)("linearGradient", {
          id: "b",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [(0, import_jsx_runtime2.jsx)("stop", {
            stopColor: "#fff"
          }), (0, import_jsx_runtime2.jsx)("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  avalanche: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("path", {
        fill: "#fff",
        d: "M23 5H5v18h18V5Z"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "#E84142",
        fillRule: "evenodd",
        d: "M14 28c-7.513.008-14-6.487-14-14C0 6.196 6.043-.008 14 0c7.95.008 14 6.196 14 14 0 7.505-6.495 13.992-14 14Zm-3.971-7.436H7.315c-.57 0-.851 0-1.023-.11a.69.69 0 0 1-.313-.54c-.01-.202.13-.45.412-.944l6.7-11.809c.285-.501.43-.752.612-.845.195-.1.429-.1.625 0 .182.093.326.344.611.845l1.377 2.404.007.013c.308.538.464.81.533 1.097a2.04 2.04 0 0 1 0 .954c-.07.289-.224.564-.536 1.11l-3.52 6.22-.009.017c-.31.542-.467.817-.684 1.024a2.048 2.048 0 0 1-.835.485c-.285.079-.604.079-1.243.079Zm6.852 0h3.888c.574 0 .862 0 1.034-.113a.687.687 0 0 0 .313-.543c.01-.196-.128-.434-.398-.9a8.198 8.198 0 0 1-.028-.048l-1.948-3.332-.022-.037c-.274-.463-.412-.697-.59-.787a.684.684 0 0 0-.621 0c-.179.093-.323.337-.608.828l-1.94 3.331-.007.012c-.284.49-.426.735-.416.936.014.22.127.423.313.543.168.11.456.11 1.03.11Z",
        clipRule: "evenodd"
      })]
    })
  },
  optimism: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("rect", {
        width: "28",
        height: "28",
        fill: "#FF3131",
        rx: "14"
      }), (0, import_jsx_runtime2.jsx)("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "#fff",
        d: "M9.22 18.35c2.7 0 4.86-2.2 4.86-5.38 0-2.19-1.47-3.8-3.98-3.8-2.72 0-4.85 2.2-4.85 5.38 0 2.2 1.5 3.8 3.97 3.8Zm.83-7.35c1.06 0 1.74.81 1.74 2.1 0 1.9-1.11 3.42-2.51 3.42-1.06 0-1.74-.82-1.74-2.1 0-1.89 1.11-3.42 2.5-3.42Zm6.38-1.68-1.88 8.88h2.26l.55-2.6h1.47c2.43 0 4.01-1.38 4.01-3.6 0-1.61-1.17-2.68-3.1-2.68h-3.3Zm1.9 1.74h.94c.83 0 1.3.38 1.3 1.14 0 1-.68 1.7-1.74 1.7h-1.11l.6-2.84Z"
      }), (0, import_jsx_runtime2.jsx)("defs", {
        children: (0, import_jsx_runtime2.jsxs)("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [(0, import_jsx_runtime2.jsx)("stop", {
            stopColor: "#fff"
          }), (0, import_jsx_runtime2.jsx)("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  polygon: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("rect", {
        width: "28",
        height: "28",
        fill: "#8247E5",
        rx: "14"
      }), (0, import_jsx_runtime2.jsx)("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), (0, import_jsx_runtime2.jsx)("path", {
        fill: "#fff",
        d: "M18.28 10.92a1.06 1.06 0 0 0-1.06 0l-2.41 1.42-1.65.93-2.41 1.43c-.31.19-.72.19-1.06 0l-1.92-1.12a1.07 1.07 0 0 1-.53-.9v-2.2a1 1 0 0 1 .53-.9l1.9-1.08c.3-.18.7-.18 1.04 0l1.9 1.09c.3.18.52.52.52.9v1.42l1.64-.96V9.52a1 1 0 0 0-.52-.9l-3.5-2.04a1.06 1.06 0 0 0-1.06 0L6.13 8.63a1 1 0 0 0-.53.9v4.12a1 1 0 0 0 .53.9l3.56 2.04c.31.19.71.19 1.06 0l2.41-1.4 1.65-.95 2.41-1.4c.31-.19.72-.19 1.06 0l1.89 1.09c.3.18.53.52.53.9v2.2a1 1 0 0 1-.53.9l-1.9 1.11c-.3.19-.7.19-1.05 0l-1.89-1.08a1.07 1.07 0 0 1-.52-.9v-1.43l-1.65.96v1.43a1 1 0 0 0 .53.9l3.56 2.04c.31.19.72.19 1.06 0l3.56-2.04c.31-.19.53-.53.53-.9v-4.13a1 1 0 0 0-.53-.9l-3.6-2.07Z"
      }), (0, import_jsx_runtime2.jsx)("defs", {
        children: (0, import_jsx_runtime2.jsxs)("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [(0, import_jsx_runtime2.jsx)("stop", {
            stopColor: "#fff"
          }), (0, import_jsx_runtime2.jsx)("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  fantom: {
    svgProps: {
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsxs)("defs", {
        children: [(0, import_jsx_runtime2.jsx)("style", {
          children: ".cls-1{fill:#fff;fill-rule:evenodd}"
        }), (0, import_jsx_runtime2.jsx)("mask", {
          id: "mask",
          width: 93.1,
          height: 20,
          x: 10,
          y: 6,
          maskUnits: "userSpaceOnUse",
          children: (0, import_jsx_runtime2.jsx)("path", {
            id: "a",
            d: "M10 6h93.1v20H10Z",
            className: "cls-1"
          })
        })]
      }), (0, import_jsx_runtime2.jsx)("g", {
        id: "Layer_2",
        "data-name": "Layer 2",
        children: (0, import_jsx_runtime2.jsxs)("g", {
          id: "Layer_1-2",
          "data-name": "Layer 1",
          children: [(0, import_jsx_runtime2.jsx)("circle", {
            cx: 16,
            cy: 16,
            r: 16,
            fill: "#13b5ec"
          }), (0, import_jsx_runtime2.jsx)("path", {
            d: "m17.2 12.9 3.6-2.1V15Zm3.6 9L16 24.7l-4.8-2.8V17l4.8 2.8 4.8-2.8Zm-9.6-11.1 3.6 2.1-3.6 2.1Zm5.4 3.1 3.6 2.1-3.6 2.1Zm-1.2 4.2L11.8 16l3.6-2.1Zm4.8-8.3L16 12.2l-4.2-2.4L16 7.3ZM10 9.4v13.1l6 3.4 6-3.4V9.4L16 6Z",
            className: "cls-1"
          })]
        })
      })]
    })
  },
  binance: {
    svgProps: {
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg"
    },
    paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)("polygon", {
        fill: "#F3BA2F",
        points: "38.171,53.203 62.759,28.616 87.36,53.216 101.667,38.909 62.759,0 23.864,38.896 "
      }), (0, import_jsx_runtime2.jsx)("rect", {
        x: "3.644",
        y: "53.188",
        transform: "matrix(0.7071 0.7071 -0.7071 0.7071 48.7933 8.8106)",
        fill: "#F3BA2F",
        width: "20.233",
        height: "20.234"
      }), (0, import_jsx_runtime2.jsx)("polygon", {
        fill: "#F3BA2F",
        points: "38.171,73.408 62.759,97.995 87.359,73.396 101.674,87.695 101.667,87.703 62.759,126.61123.863,87.716 23.843,87.696 "
      }), (0, import_jsx_runtime2.jsx)("rect", {
        x: "101.64",
        y: "53.189",
        transform: "matrix(-0.7071 0.7071 -0.7071 -0.7071 235.5457 29.0503)",
        fill: "#F3BA2F",
        width: "20.234",
        height: "20.233"
      }), (0, import_jsx_runtime2.jsx)("polygon", {
        fill: "#F3BA2F",
        points: "77.271,63.298 77.277,63.298 62.759,48.78 52.03,59.509 52.029,59.509 50.797,60.742 48.254,63.28548.254,63.285 48.234,63.305 48.254,63.326 62.759,77.831 77.277,63.313 77.284,63.305 "
      })]
    })
  }
};
var CoinbaseWalletIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)("rect", {
      width: "28",
      height: "28",
      fill: "#2C5FF6"
    }), (0, import_jsx_runtime2.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z",
      fill: "white"
    })]
  })
};
var MetamaskIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)("rect", {
      width: "28",
      height: "28",
      fill: "white"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M24.0891 3.1199L15.3446 9.61456L16.9617 5.7828L24.0891 3.1199Z",
      fill: "#E2761B",
      stroke: "#E2761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M3.90207 3.1199L12.5763 9.67608L11.0383 5.7828L3.90207 3.1199Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M20.9429 18.1745L18.6139 21.7426L23.597 23.1136L25.0295 18.2536L20.9429 18.1745Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M2.97929 18.2536L4.40301 23.1136L9.38607 21.7426L7.05713 18.1745L2.97929 18.2536Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.10483 12.1456L7.71626 14.2461L12.6642 14.4658L12.4884 9.14877L9.10483 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M18.8864 12.1456L15.4589 9.08725L15.3446 14.4658L20.2837 14.2461L18.8864 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.38606 21.7426L12.3566 20.2925L9.79033 18.2888L9.38606 21.7426Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.6347 20.2925L18.6139 21.7426L18.2009 18.2888L15.6347 20.2925Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M18.6139 21.7426L15.6347 20.2925L15.8719 22.2348L15.8456 23.0521L18.6139 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.38606 21.7426L12.1544 23.0521L12.1368 22.2348L12.3566 20.2925L9.38606 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M12.1984 17.0056L9.72002 16.2762L11.4689 15.4765L12.1984 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.7928 17.0056L16.5223 15.4765L18.28 16.2762L15.7928 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.38606 21.7426L9.80791 18.1745L7.05712 18.2536L9.38606 21.7426Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M18.1921 18.1745L18.6139 21.7426L20.9429 18.2536L18.1921 18.1745Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M20.2837 14.2461L15.3446 14.4658L15.8016 17.0057L16.5311 15.4765L18.2888 16.2762L20.2837 14.2461Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.72002 16.2762L11.4777 15.4765L12.1984 17.0057L12.6642 14.4658L7.71626 14.2461L9.72002 16.2762Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M7.71626 14.2461L9.79033 18.2888L9.72002 16.2762L7.71626 14.2461Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M18.2888 16.2762L18.2009 18.2888L20.2837 14.2461L18.2888 16.2762Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M12.6642 14.4658L12.1984 17.0057L12.7784 20.0025L12.9102 16.0565L12.6642 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.3446 14.4658L15.1073 16.0477L15.2128 20.0025L15.8016 17.0057L15.3446 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.8016 17.0056L15.2128 20.0025L15.6347 20.2925L18.2009 18.2888L18.2888 16.2762L15.8016 17.0056Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.72002 16.2762L9.79033 18.2888L12.3566 20.2925L12.7784 20.0025L12.1984 17.0056L9.72002 16.2762Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.8456 23.0521L15.8719 22.2348L15.6522 22.0414H12.339L12.1368 22.2348L12.1544 23.0521L9.38606 21.7426L10.3528 22.5336L12.3126 23.8958H15.6786L17.6472 22.5336L18.6139 21.7426L15.8456 23.0521Z",
      fill: "#C0AD9E",
      stroke: "#C0AD9E",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.6347 20.2925L15.2128 20.0025H12.7784L12.3566 20.2925L12.1368 22.2348L12.339 22.0414H15.6522L15.8719 22.2348L15.6347 20.2925Z",
      fill: "#161616",
      stroke: "#161616",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M24.4583 10.0364L25.2053 6.45072L24.0891 3.1199L15.6347 9.39485L18.8864 12.1456L23.4827 13.4903L24.5022 12.3038L24.0628 11.9874L24.7658 11.3459L24.221 10.924L24.924 10.3879L24.4583 10.0364Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M2.79472 6.45072L3.54174 10.0364L3.06717 10.3879L3.77024 10.924L3.23415 11.3459L3.93722 11.9874L3.4978 12.3038L4.50847 13.4903L9.10483 12.1456L12.3566 9.39485L3.90207 3.1199L2.79472 6.45072Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M23.4827 13.4903L18.8864 12.1456L20.2837 14.2461L18.2009 18.2888L20.9429 18.2536H25.0295L23.4827 13.4903Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M9.10484 12.1456L4.50848 13.4903L2.97929 18.2536H7.05713L9.79033 18.2888L7.71626 14.2461L9.10484 12.1456Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M15.3446 14.4658L15.6347 9.39485L16.9705 5.7828H11.0383L12.3566 9.39485L12.6642 14.4658L12.7696 16.0653L12.7784 20.0025H15.2128L15.2304 16.0653L15.3446 14.4658Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  })
};
var WalletConnectIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)("rect", {
      width: "28",
      height: "28",
      fill: "#3B99FC"
    }), (0, import_jsx_runtime2.jsx)("path", {
      d: "M8.38969 10.3739C11.4882 7.27538 16.5118 7.27538 19.6103 10.3739L19.9832 10.7468C20.1382 10.9017 20.1382 11.1529 19.9832 11.3078L18.7076 12.5835C18.6301 12.6609 18.5045 12.6609 18.4271 12.5835L17.9139 12.0703C15.7523 9.9087 12.2477 9.9087 10.0861 12.0703L9.53655 12.6198C9.45909 12.6973 9.3335 12.6973 9.25604 12.6198L7.98039 11.3442C7.82547 11.1893 7.82547 10.9381 7.98039 10.7832L8.38969 10.3739ZM22.2485 13.012L23.3838 14.1474C23.5387 14.3023 23.5387 14.5535 23.3838 14.7084L18.2645 19.8277C18.1096 19.9827 17.8584 19.9827 17.7035 19.8277C17.7035 19.8277 17.7035 19.8277 17.7035 19.8277L14.0702 16.1944C14.0314 16.1557 13.9686 16.1557 13.9299 16.1944C13.9299 16.1944 13.9299 16.1944 13.9299 16.1944L10.2966 19.8277C10.1417 19.9827 9.89053 19.9827 9.73561 19.8278C9.7356 19.8278 9.7356 19.8277 9.7356 19.8277L4.61619 14.7083C4.46127 14.5534 4.46127 14.3022 4.61619 14.1473L5.75152 13.012C5.90645 12.857 6.15763 12.857 6.31255 13.012L9.94595 16.6454C9.98468 16.6841 10.0475 16.6841 10.0862 16.6454C10.0862 16.6454 10.0862 16.6454 10.0862 16.6454L13.7194 13.012C13.8743 12.857 14.1255 12.857 14.2805 13.012C14.2805 13.012 14.2805 13.012 14.2805 13.012L17.9139 16.6454C17.9526 16.6841 18.0154 16.6841 18.0541 16.6454L21.6874 13.012C21.8424 12.8571 22.0936 12.8571 22.2485 13.012Z",
      fill: "white"
    })]
  })
};
var StyledSvg = emotion_styled_browser_esm_default.svg`
  border-radius: 0.25em;
  flex-shrink: 0;
  ${(props) => props.boxSize ? `width: ${props.boxSize};
    height: ${props.boxSize};` : ""}
`;
var iconMap = {
  metamask: MetamaskIcon,
  walletConnect: WalletConnectIcon,
  coinbaseWallet: CoinbaseWalletIcon,
  ...chainLogos
};
var Icon = (_ref) => {
  let {
    name,
    ...props
  } = _ref;
  const icon = iconMap[name];
  return (0, import_jsx_runtime2.jsx)(StyledSvg, {
    ...icon.svgProps,
    ...props,
    children: icon.paths
  });
};
var MenuItemBase = emotion_styled_browser_esm_default.li`
  display: flex;
  padding: 0.75em 1em;
  align-items: center;
  gap: 0.5em;
  font-size: 1em;

  ${(props) => props.isSelectable ? `&:hover,
  &[data-focus] {
    cursor: pointer;
    background: ${(0, import_color.default)(props.theme.colors.text).alpha(0.15).hexa()};
  }` : ``}

  > svg {
    flex-shrink: 0;
  }
`;
var MenuItem = (_ref) => {
  let {
    children,
    leftElement,
    rightElement,
    isSelectable = true,
    onClick,
    ...restProps
  } = _ref;
  return (0, import_jsx_runtime2.jsxs)(MenuItemBase, {
    ...restProps,
    onClick: isSelectable ? onClick : void 0,
    isSelectable,
    children: [leftElement, children, rightElement]
  });
};
var Menu = emotion_styled_browser_esm_default.ul`
  padding: 0;
  margin: 0;
  background: ${(props) => props.theme.colors.background};
  color: ${(props) => props.theme.colors.text};
  list-style: none;
  border-radius: 0.5em;
  overflow: hidden;
  position: relative;
  pointer-events: auto;
  &:focus {
    outline: 0;
  }
  &:after {
    content: "";
    position: absolute;
    border: 1px solid ${(props) => props.theme.colors.accent};
    border-radius: 0.5em;
    pointer-events: none;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
`;
var lightModeTheme = {
  colors: {
    accent: "#fff",
    background: "#fff",
    text: "#000"
  }
};
var darkModeTheme = {
  colors: {
    accent: "#000",
    background: "#000",
    text: "#fff"
  }
};
var fontFamily = `SFRounded, ui-rounded, "SF Pro Rounded", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var ThemeProvider2 = (_ref) => {
  let {
    colorMode,
    accentColor,
    children
  } = _ref;
  const theme = (0, import_react6.useMemo)(() => {
    const t2 = colorMode === "light" ? lightModeTheme : darkModeTheme;
    return {
      ...t2,
      colors: {
        ...t2.colors,
        accent: accentColor || t2.colors.accent
      }
    };
  }, [accentColor, colorMode]);
  return (0, import_jsx_runtime2.jsx)(ThemeProvider, {
    theme,
    children: (0, import_jsx_runtime2.jsx)("span", {
      style: {
        fontFamily
      },
      children
    })
  });
};
var Select = emotion_styled_browser_esm_default.select`
  margin: -0.25em 0;
  background: ${(props) => (0, import_color.default)(props.theme.colors.background).alpha(0.85).hexa()};
  color: ${(props) => props.theme.colors.text};
  border: 1px solid
    ${(props) => (0, import_color.default)(props.theme.colors.text).alpha(0.25).hexa()};
  border-radius: 0.25em;
  padding: 0.25em;
  width: 100%;
  flex-shrink: 1;
  font-size: 1em;
  &:hover {
    cursor: pointer;
  }
  &:focus {
    outline: 2px solid ${(props) => props.theme.colors.accent};
  }
  &:disabled {
    cursor: not-allowed;
  }
`;
var SupportedNetworkSelect = (_ref) => {
  let {
    disabledChainIds,
    ...selectProps
  } = _ref;
  const deprecatedNetworks = (0, import_react6.useMemo)(() => {
    return SUPPORTED_CHAIN_IDS.map((supportedChain) => {
      return getChainFromChainId(supportedChain);
    });
  }, []);
  const testnets = (0, import_react6.useMemo)(() => {
    return SUPPORTED_CHAIN_IDS.map((supportedChain) => {
      return getChainFromChainId(supportedChain);
    });
  }, []);
  const mainnets = (0, import_react6.useMemo)(() => {
    return SUPPORTED_CHAIN_IDS.map((supportedChain) => {
      return getChainFromChainId(supportedChain);
    });
  }, []);
  return (0, import_jsx_runtime2.jsxs)(Select, {
    ...selectProps,
    children: [(0, import_jsx_runtime2.jsx)("option", {
      disabled: true,
      value: -1,
      children: "Select Network"
    }), (0, import_jsx_runtime2.jsx)("optgroup", {
      label: "Mainnets",
      children: mainnets.map((mn) => {
        var _a;
        return (0, import_jsx_runtime2.jsxs)("option", {
          value: mn.id,
          disabled: disabledChainIds == null ? void 0 : disabledChainIds.includes(mn.id),
          children: [mn.name, " (", (_a = mn.nativeCurrency) == null ? void 0 : _a.symbol, ")"]
        }, mn.id);
      })
    }), (0, import_jsx_runtime2.jsx)("optgroup", {
      label: "Testnets",
      children: testnets.map((tn) => {
        var _a;
        return (0, import_jsx_runtime2.jsxs)("option", {
          value: tn.id,
          disabled: disabledChainIds == null ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_a = tn.nativeCurrency) == null ? void 0 : _a.symbol, ")"]
        }, tn.id);
      })
    }), (0, import_jsx_runtime2.jsx)("optgroup", {
      label: "Deprecated",
      children: deprecatedNetworks.map((tn) => {
        var _a;
        return (0, import_jsx_runtime2.jsxs)("option", {
          value: tn.id,
          disabled: disabledChainIds == null ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_a = tn.nativeCurrency) == null ? void 0 : _a.symbol, ")"]
        }, tn.id);
      })
    })]
  });
};
var SUPPORTED_CONNECTORS = ["injected", "walletConnect", "coinbasewallet"];
function getIconForConnector(connector) {
  if (connector.name.toLowerCase().includes("coinbase")) {
    return (0, import_jsx_runtime2.jsx)(Icon, {
      boxSize: "1.5em",
      name: "coinbaseWallet"
    });
  }
  if (connector.name.toLocaleLowerCase().includes("metamask")) {
    return (0, import_jsx_runtime2.jsx)(Icon, {
      boxSize: "1.5em",
      name: "metamask"
    });
  }
  const id = connector.id;
  switch (id) {
    case "injected":
      return (0, import_jsx_runtime2.jsx)(Icon, {
        boxSize: "1.5em",
        name: "metamask"
      });
    case "walletConnect":
      return (0, import_jsx_runtime2.jsx)(Icon, {
        boxSize: "1.5em",
        name: "walletConnect"
      });
    case "coinbasewallet":
      return (0, import_jsx_runtime2.jsx)(Icon, {
        boxSize: "1.5em",
        name: "coinbaseWallet"
      });
    default:
      throw new Error("unsupported connector");
  }
}
var connecting = false;
var switchingNetwork = false;
var authing = false;
var switchingWallet = false;
var chainIdToCurrencyMap = {
  [ChainId.Mainnet]: "ethereum",
  [ChainId.Goerli]: "ethereum",
  [ChainId.Arbitrum]: "arbitrum",
  [ChainId.ArbitrumGoerli]: "arbitrum",
  [ChainId.Avalanche]: "avalanche",
  [ChainId.AvalancheFujiTestnet]: "avalanche",
  [ChainId.Fantom]: "fantom",
  [ChainId.FantomTestnet]: "fantom",
  [ChainId.Optimism]: "optimism",
  [ChainId.OptimismGoerli]: "optimism",
  [ChainId.Polygon]: "polygon",
  [ChainId.Mumbai]: "polygon",
  [ChainId.BinanceSmartChainMainnet]: "binance",
  [ChainId.BinanceSmartChainTestnet]: "binance"
};
var ConnectWallet = (_ref) => {
  var _a, _b;
  let {
    auth,
    className,
    btnTitle,
    ...themeProps
  } = _ref;
  const id = (0, import_react6.useId)();
  const walletAddress = useAddress();
  const [state, send] = useMachine(machine({
    id,
    closeOnSelect: true,
    positioning: {
      sameWidth: true
    }
  }));
  const api = connect(state, send, normalizeProps);
  const [{
    data: {
      connectors,
      connector
    }
  }, connect2] = useConnect2();
  const disconnect = useDisconnect({
    reconnectPrevious: false
  });
  const supportedConnectors = connectors.filter((c2) => SUPPORTED_CONNECTORS.includes(c2.id));
  const [network, switchNetwork] = useNetwork2();
  const chainId = useChainId();
  const connectWithMetamask = useMetamask();
  const balanceQuery = useBalance();
  const {
    onCopy,
    hasCopied
  } = useClipboard(walletAddress || "");
  const authConfig = useThirdwebAuthConfig();
  const {
    user,
    isLoading,
    login,
    logout
  } = useAuth(auth == null ? void 0 : auth.loginConfig);
  const requiresSignIn = (auth == null ? void 0 : auth.loginOptional) ? false : !!(authConfig == null ? void 0 : authConfig.authUrl) && !!walletAddress && !(user == null ? void 0 : user.address);
  return (0, import_jsx_runtime2.jsx)(ThemeProvider2, {
    ...themeProps,
    children: (0, import_jsx_runtime2.jsxs)("div", {
      style: {
        position: "relative",
        width: "100%"
      },
      children: [(0, import_jsx_runtime2.jsx)(Button, {
        className,
        style: {
          height: "50px",
          minWidth: "200px",
          width: "100%"
        },
        onClick: async (e2) => {
          if (requiresSignIn) {
            e2.preventDefault();
            e2.stopPropagation();
            authing = true;
            try {
              await login(auth == null ? void 0 : auth.loginOptions);
            } catch (err) {
              console.error("failed to log in", err);
            }
            authing = false;
          }
        },
        ...requiresSignIn ? {} : api.triggerProps,
        leftElement: requiresSignIn ? isLoading ? (0, import_jsx_runtime2.jsx)(Spinner, {}) : (0, import_jsx_runtime2.jsx)(import_FiLock.FiLock, {}) : walletAddress && chainId && chainId in chainIdToCurrencyMap ? (0, import_jsx_runtime2.jsx)(Icon, {
          boxSize: "1.5em",
          name: chainIdToCurrencyMap[chainId]
        }) : void 0,
        rightElement: requiresSignIn ? void 0 : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
          children: [connector && getIconForConnector(connector), (0, import_jsx_runtime2.jsx)(import_FiChevronDown.FiChevronDown, {
            style: {
              transition: "transform 150ms ease",
              transform: `rotate(${api.isOpen ? "-180deg" : "0deg"})`
            }
          })]
        }),
        children: walletAddress ? requiresSignIn ? (0, import_jsx_runtime2.jsx)("span", {
          style: {
            whiteSpace: "nowrap"
          },
          children: "Sign in"
        }) : (0, import_jsx_runtime2.jsxs)("span", {
          style: {
            display: "flex",
            flexDirection: "column",
            fontWeight: 400,
            alignItems: "flex-start",
            fontSize: "0.8em"
          },
          children: [(0, import_jsx_runtime2.jsx)("span", {
            style: {
              whiteSpace: "nowrap",
              fontWeight: 500
            },
            children: balanceQuery.isLoading ? "Loading..." : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
              children: [(_a = balanceQuery.data) == null ? void 0 : _a.displayValue.slice(0, 5), " ", (_b = balanceQuery.data) == null ? void 0 : _b.symbol]
            })
          }), (0, import_jsx_runtime2.jsx)("span", {
            style: {
              fontSize: "0.9em"
            },
            children: shortenIfAddress(walletAddress)
          })]
        }) : (0, import_jsx_runtime2.jsx)("span", {
          style: {
            whiteSpace: "nowrap"
          },
          children: btnTitle || "Connect Wallet"
        })
      }), (0, import_jsx_runtime2.jsx)(Portal2, {
        children: (0, import_jsx_runtime2.jsx)(Box, {
          ...api.positionerProps,
          style: {
            zIndex: 9999,
            fontFamily
          },
          children: (0, import_jsx_runtime2.jsx)(Menu, {
            ...api.contentProps,
            children: !api.isOpen ? null : walletAddress ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
              children: [(authConfig == null ? void 0 : authConfig.authUrl) && !(user == null ? void 0 : user.address) && !requiresSignIn ? (0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "auth",
                  closeOnSelect: false
                }),
                leftElement: isLoading ? (0, import_jsx_runtime2.jsx)(Spinner, {}) : (0, import_jsx_runtime2.jsx)(import_FiLock.FiLock, {}),
                onClick: async () => {
                  if (isLoading || authing || (user == null ? void 0 : user.address)) {
                    return;
                  }
                  authing = true;
                  try {
                    await login(auth == null ? void 0 : auth.loginOptions);
                  } catch (err) {
                    console.error("failed to log in", err);
                  }
                  authing = false;
                },
                children: "Sign in"
              }) : null, (0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "copy",
                  closeOnSelect: false
                }),
                leftElement: hasCopied ? (0, import_jsx_runtime2.jsx)(import_FiCheck.FiCheck, {
                  width: "1em",
                  height: "1em",
                  color: "#57ab5a"
                }) : (0, import_jsx_runtime2.jsx)(import_FiCopy.FiCopy, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: () => {
                  onCopy();
                },
                children: "Copy address"
              }), (0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "switch-network",
                  closeOnSelect: false,
                  disabled: !switchNetwork
                }),
                isSelectable: false,
                leftElement: network.loading ? (0, import_jsx_runtime2.jsx)(Spinner, {}) : network.error ? (0, import_jsx_runtime2.jsx)(import_FiWifi.FiWifi, {
                  color: "#e5534b",
                  width: "1em",
                  height: "1em"
                }) : (0, import_jsx_runtime2.jsx)(import_FiWifi.FiWifi, {
                  width: "1em",
                  height: "1em"
                }),
                children: (0, import_jsx_runtime2.jsx)(SupportedNetworkSelect, {
                  value: chainId,
                  disabled: !switchNetwork,
                  onChange: async (e2) => {
                    if (!switchingNetwork && switchNetwork) {
                      switchingNetwork = true;
                      const number = parseInt(e2.target.value);
                      try {
                        await switchNetwork(number);
                      } catch (err) {
                        console.error("failed to switch network", err);
                      } finally {
                        switchingNetwork = false;
                      }
                    }
                  }
                })
              }), connector && connector.name === "MetaMask" && connector.id === "injected" ? (0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "switch-wallet"
                }),
                leftElement: (0, import_jsx_runtime2.jsx)(import_FiShuffle.FiShuffle, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: async () => {
                  if (switchingWallet) {
                    return;
                  }
                  switchingWallet = true;
                  try {
                    await connector.getProvider().request({
                      method: "wallet_requestPermissions",
                      params: [{
                        eth_accounts: {}
                      }]
                    });
                    api.close();
                  } catch (err) {
                    console.error("failed to switch wallets", err);
                  }
                  switchingWallet = false;
                },
                children: "Switch Account"
              }) : null, (0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "disconnect"
                }),
                leftElement: (0, import_jsx_runtime2.jsx)(import_FiXCircle.FiXCircle, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: () => {
                  disconnect();
                  if (authConfig == null ? void 0 : authConfig.authUrl) {
                    logout();
                  }
                  api.close();
                },
                children: "Disconnect"
              })]
            }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
              children: [(0, import_jsx_runtime2.jsx)(MenuItem, {
                ...api.getItemProps({
                  id: "metamask"
                }),
                onClick: async () => {
                  if (!connecting) {
                    try {
                      connecting = true;
                      await connectWithMetamask();
                      api.close();
                    } finally {
                      connecting = false;
                    }
                  }
                },
                leftElement: (0, import_jsx_runtime2.jsx)(Icon, {
                  boxSize: "1.5em",
                  name: "metamask"
                }),
                children: "MetaMask"
              }), supportedConnectors.filter((c2) => c2.name !== "MetaMask").sort((a2, b) => a2.name.localeCompare(b.name)).map((c2) => {
                if (!c2.ready) {
                  return null;
                }
                return (0, import_jsx_runtime2.jsx)(MenuItem, {
                  ...api.getItemProps({
                    id: c2.id
                  }),
                  onClick: async () => {
                    if (!connecting) {
                      try {
                        connecting = true;
                        await connect2(c2);
                        api.close();
                      } finally {
                        connecting = false;
                      }
                    }
                  },
                  leftElement: getIconForConnector(c2),
                  children: c2.name
                }, c2.id);
              })]
            })
          })
        })
      })]
    })
  });
};
var Web3Button = (_ref) => {
  let {
    contractAddress,
    onSuccess,
    onError,
    onSubmit,
    isDisabled,
    contractAbi,
    children,
    action,
    className,
    ...themeProps
  } = _ref;
  const address = useAddress();
  const walletChainId = useChainId();
  const sdkChainId = useSDKChainId();
  const [, switchNetwork] = useNetwork2();
  const queryClient = useQueryClient();
  const hasMismatch = useNetworkMismatch();
  const switchToChainId = (0, import_react6.useMemo)(() => {
    if (sdkChainId && walletChainId && sdkChainId !== walletChainId) {
      return sdkChainId;
    }
    return null;
  }, [sdkChainId, walletChainId]);
  const {
    contract
  } = useContract(contractAddress, contractAbi || "custom");
  const mutation = useMutation(async () => {
    if (switchToChainId) {
      if (switchNetwork) {
        await switchNetwork(switchToChainId);
        return "__NETWORK_SWITCHED__";
      } else {
        throw new Error("need to switch chain but connected wallet does not support switching");
      }
    }
    invariant(contract, "contract is not ready yet");
    if (onSubmit) {
      onSubmit();
    }
    return await action(contract);
  }, {
    onSuccess: (res) => {
      if (res === "__NETWORK_SWITCHED__") {
        return;
      }
      if (onSuccess) {
        onSuccess(res);
      }
    },
    onError: (err) => {
      if (onError) {
        onError(err);
      }
    },
    onSettled: () => queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), sdkChainId))
  });
  if (!address) {
    return (0, import_jsx_runtime2.jsx)(ConnectWallet, {
      className,
      ...themeProps
    });
  }
  const willSwitchNetwork = hasMismatch && !!switchNetwork;
  return (0, import_jsx_runtime2.jsx)(ThemeProvider2, {
    ...themeProps,
    children: (0, import_jsx_runtime2.jsx)(Button, {
      className,
      style: {
        height: "50px",
        minWidth: "200px",
        width: "100%"
      },
      isLoading: mutation.isLoading || !contract,
      onClick: () => mutation.mutate(),
      isDisabled: willSwitchNetwork ? false : isDisabled,
      leftElement: willSwitchNetwork ? (0, import_jsx_runtime2.jsx)(import_FiWifi.FiWifi, {
        width: "1em",
        height: "1em"
      }) : void 0,
      children: willSwitchNetwork ? "Switch Network" : children
    })
  });
};

// node_modules/@thirdweb-dev/react/dist/thirdweb-dev-react.esm.js
var import_react9 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_buffer2 = __toESM(require_buffer());
var import_lite2 = __toESM(require_lite());
var import_react_dom3 = __toESM(require_react_dom());
var import_copy_to_clipboard2 = __toESM(require_copy_to_clipboard());
init_emotion_styled_browser_esm();
init_emotion_react_browser_esm();
var import_color2 = __toESM(require_color());
var import_FiCheck2 = __toESM(require_FiCheck());
var import_FiChevronDown2 = __toESM(require_FiChevronDown());
var import_FiCopy2 = __toESM(require_FiCopy());
var import_FiLock2 = __toESM(require_FiLock());
var import_FiShuffle2 = __toESM(require_FiShuffle());
var import_FiWifi2 = __toESM(require_FiWifi());
var import_FiXCircle2 = __toESM(require_FiXCircle());
export {
  ChainId,
  ConnectWallet,
  MediaRenderer,
  ThirdwebNftMedia,
  ThirdwebProvider,
  ThirdwebSDKProvider,
  Web3Button,
  WrappedThirdwebSDKProvider,
  compilerMetadata,
  contractType,
  getErc1155,
  getErc20,
  getErc721,
  getErcs,
  shouldNeverPersistQuery,
  useAcceptDirectListingOffer,
  useAccount2 as useAccount,
  useActiveClaimCondition,
  useActiveClaimConditionForWallet,
  useActiveListings,
  useAddress,
  useAirdropNFT,
  useAllRoleMembers,
  useAuctionWinner,
  useAuth,
  useBalance,
  useBatchesToReveal,
  useBidBuffer,
  useBurnNFT,
  useBurnToken,
  useBuyNow,
  useCancelListing,
  useChainId,
  useClaimConditions,
  useClaimIneligibilityReasons,
  useClaimNFT,
  useClaimToken,
  useClaimedNFTSupply,
  useClaimedNFTs,
  useClaimerProofs,
  useCoinbaseWallet,
  useCompilerMetadata,
  useConnect2 as useConnect,
  useConnectedWallet,
  useContract,
  useContractEvents,
  useContractMetadata,
  useContractMetadataUpdate,
  useContractRead,
  useContractType,
  useContractWrite,
  useCreateAuctionListing,
  useCreateDirectListing,
  useDelayedRevealLazyMint,
  useDesiredChainId,
  useDisconnect,
  useEdition,
  useEditionDrop,
  useExecuteAuctionSale,
  useGrantRole,
  useIsAddressRole,
  useLazyMint,
  useListing,
  useListings,
  useListingsCount,
  useLogin,
  useLogout,
  useMakeBid,
  useMakeOffer,
  useMarketplace,
  useMetadata,
  useMetamask,
  useMinimumNextBid,
  useMintNFT,
  useMintNFTSupply,
  useMintToken,
  useMultiwrap,
  useNFT,
  useNFTBalance,
  useNFTCollection,
  useNFTDrop,
  useNFTs,
  useNetwork2 as useNetwork,
  useNetworkMismatch,
  useOffers,
  useOwnedNFTs,
  usePack,
  usePlatformFees,
  usePrimarySaleRecipient,
  useReadonlySDK,
  useResetClaimConditions,
  useResolvedMediaType,
  useRevealLazyMint,
  useRevokeRole,
  useRoleMembers,
  useRoyaltySettings,
  useSDK,
  useSDKChainId,
  useSetAllRoleMembers,
  useSetClaimConditions,
  useSignatureDrop,
  useSigner2 as useSigner,
  useSplit,
  useStorage,
  useStorageUpload,
  useToken,
  useTokenBalance,
  useTokenDecimals,
  useTokenDrop,
  useTokenSupply,
  useTotalCirculatingSupply,
  useTotalCount,
  useTransferBatchToken,
  useTransferNFT,
  useTransferToken,
  useUnclaimedNFTSupply,
  useUnclaimedNFTs,
  useUpdateMetadata,
  useUpdatePlatformFees,
  useUpdatePrimarySaleRecipient,
  useUpdateRoyaltySettings,
  useUser,
  useVote,
  useWalletConnect,
  useWalletLink,
  useWinningBid
};
//# sourceMappingURL=@thirdweb-dev_react.js.map
